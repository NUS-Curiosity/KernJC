configurations:
- nodes:
  - cpeMatch:
    - criteria: cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*
      matchCriteriaId: AF60D859-5B7E-4CFA-9318-AFEFAB130E64
      versionEndExcluding: 5.15.89
      versionStartIncluding: '5.15'
      vulnerable: true
    - criteria: cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*
      matchCriteriaId: 9275C81F-AE96-4CDB-AD20-7DBD36E5D909
      versionEndExcluding: 6.1.7
      versionStartIncluding: '5.16'
      vulnerable: true
    negate: false
    operator: OR
cveTags: []
descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    sched/core: Fix use-after-free bug in dup_user_cpus_ptr()


    Since commit 07ec77a1d4e8 ("sched: Allow task CPU affinity to be

    restricted on asymmetric systems"), the setting and clearing of

    user_cpus_ptr are done under pi_lock for arm64 architecture. However,

    dup_user_cpus_ptr() accesses user_cpus_ptr without any lock

    protection. Since sched_setaffinity() can be invoked from another

    process, the process being modified may be undergoing fork() at

    the same time.  When racing with the clearing of user_cpus_ptr in

    __set_cpus_allowed_ptr_locked(), it can lead to user-after-free and

    possibly double-free in arm64 kernel.


    Commit 8f9ea86fdf99 ("sched: Always preserve the user requested

    cpumask") fixes this problem as user_cpus_ptr, once set, will never

    be cleared in a task''s lifetime. However, this bug was re-introduced

    in commit 851a723e45d1 ("sched: Always clear user_cpus_ptr in

    do_set_cpus_allowed()") which allows the clearing of user_cpus_ptr in

    do_set_cpus_allowed(). This time, it will affect all arches.


    Fix this bug by always clearing the user_cpus_ptr of the newly

    cloned/forked task before the copying process starts and check the

    user_cpus_ptr state of the source task under pi_lock.


    Note to stable, this patch won''t be applicable to stable releases.

    Just copy the new dup_user_cpus_ptr() function over.'
- lang: es
  value: "En el kernel de Linux, se resolvi\xF3 la siguiente vulnerabilidad: sched/core:\
    \ corrige el error de use-after-free en dup_user_cpus_ptr() Desde el commit 07ec77a1d4e8\
    \ (\"sched: permitir que la afinidad de la CPU de la tarea se restrinja en sistemas\
    \ asim\xE9tricos\"), la configuraci\xF3n y La limpieza de user_cpus_ptr se realiza\
    \ en pi_lock para la arquitectura arm64. Sin embargo, dup_user_cpus_ptr() accede\
    \ a user_cpus_ptr sin ninguna protecci\xF3n de bloqueo. Dado que sched_setaffinity()\
    \ puede invocarse desde otro proceso, el proceso que se est\xE1 modificando puede\
    \ estar pasando por fork() al mismo tiempo. Cuando se corre con la limpieza de\
    \ user_cpus_ptr en __set_cpus_allowed_ptr_locked(), puede llevar a una liberaci\xF3\
    n posterior del usuario y posiblemente a una liberaci\xF3n doble en el kernel\
    \ arm64. El commit 8f9ea86fdf99 (\"programaci\xF3n: conservar siempre la m\xE1\
    scara de CPU solicitada por el usuario\") soluciona este problema ya que user_cpus_ptr,\
    \ una vez configurado, nunca se borrar\xE1 durante la vida de una tarea. Sin embargo,\
    \ este error se reintrodujo en el commit 851a723e45d1 (\"sched: borrar siempre\
    \ user_cpus_ptr en do_set_cpus_allowed()\") que permite borrar user_cpus_ptr en\
    \ do_set_cpus_allowed(). Esta vez afectar\xE1 a todos los arcos. Corrija este\
    \ error borrando siempre el user_cpus_ptr de la tarea reci\xE9n clonada/bifurcada\
    \ antes de que comience el proceso de copia y verifique el estado de user_cpus_ptr\
    \ de la tarea fuente en pi_lock. Nota para las versiones estables: este parche\
    \ no se aplicar\xE1 a las versiones estables. Simplemente copie la nueva funci\xF3\
    n dup_user_cpus_ptr()."
id: CVE-2022-48892
lastModified: '2024-08-29T02:35:56.343'
metrics:
  cvssMetricV31:
  - cvssData:
      attackComplexity: LOW
      attackVector: LOCAL
      availabilityImpact: HIGH
      baseScore: 7.8
      baseSeverity: HIGH
      confidentialityImpact: HIGH
      integrityImpact: HIGH
      privilegesRequired: LOW
      scope: UNCHANGED
      userInteraction: NONE
      vectorString: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H
      version: '3.1'
    exploitabilityScore: 1.8
    impactScore: 5.9
    source: nvd@nist.gov
    type: Primary
published: '2024-08-21T07:15:05.420'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  tags:
  - Patch
  url: https://git.kernel.org/stable/c/7b5cc7fd1789ea5dbb942c9f8207b076d365badc
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  tags:
  - Patch
  url: https://git.kernel.org/stable/c/87ca4f9efbd7cc649ff43b87970888f2812945b8
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  tags:
  - Patch
  url: https://git.kernel.org/stable/c/b22faa21b6230d5eccd233e1b7e0026a5002b287
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Analyzed
weaknesses:
- description:
  - lang: en
    value: CWE-415
  - lang: en
    value: CWE-416
  source: nvd@nist.gov
  type: Primary
