cveTags: []
descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    tcp: do not accept ACK of bytes we never sent\n\nThis patch is based on a detailed\
    \ report and ideas from Yepeng Pan\nand Christian Rossow.\n\nACK seq validation\
    \ is currently following RFC 5961 5.2 guidelines:\n\n   The ACK value is considered\
    \ acceptable only if\n   it is in the range of ((SND.UNA - MAX.SND.WND) <= SEG.ACK\
    \ <=\n   SND.NXT).  All incoming segments whose ACK value doesn't satisfy the\n\
    \   above condition MUST be discarded and an ACK sent back.  It needs to\n   be\
    \ noted that RFC 793 on page 72 (fifth check) says: \"If the ACK is a\n   duplicate\
    \ (SEG.ACK < SND.UNA), it can be ignored.  If the ACK\n   acknowledges something\
    \ not yet sent (SEG.ACK > SND.NXT) then send an\n   ACK, drop the segment, and\
    \ return\".  The \"ignored\" above implies that\n   the processing of the incoming\
    \ data segment continues, which means\n   the ACK value is treated as acceptable.\
    \  This mitigation makes the\n   ACK check more stringent since any ACK < SND.UNA\
    \ wouldn't be\n   accepted, instead only ACKs that are in the range ((SND.UNA\
    \ -\n   MAX.SND.WND) <= SEG.ACK <= SND.NXT) get through.\n\nThis can be refined\
    \ for new (and possibly spoofed) flows,\nby not accepting ACK for bytes that were\
    \ never sent.\n\nThis greatly improves TCP security at a little cost.\n\nI added\
    \ a Fixes: tag to make sure this patch will reach stable trees,\neven if the 'blamed'\
    \ patch was adhering to the RFC.\n\ntp->bytes_acked was added in linux-4.2\n\n\
    Following packetdrill test (courtesy of Yepeng Pan) shows\nthe issue at hand:\n\
    \n0 socket(..., SOCK_STREAM, IPPROTO_TCP) = 3\n+0 setsockopt(3, SOL_SOCKET, SO_REUSEADDR,\
    \ [1], 4) = 0\n+0 bind(3, ..., ...) = 0\n+0 listen(3, 1024) = 0\n\n// ----------------\
    \ Handshake ------------------- //\n\n// when window scale is set to 14 the window\
    \ size can be extended to\n// 65535 * (2^14) = 1073725440. Linux would accept\
    \ an ACK packet\n// with ack number in (Server_ISN+1-1073725440. Server_ISN+1)\n\
    // ,though this ack number acknowledges some data never\n// sent by the server.\n\
    \n+0 < S 0:0(0) win 65535 <mss 1400,nop,wscale 14>\n+0 > S. 0:0(0) ack 1 <...>\n\
    +0 < . 1:1(0) ack 1 win 65535\n+0 accept(3, ..., ...) = 4\n\n// For the established\
    \ connection, we send an ACK packet,\n// the ack packet uses ack number 1 - 1073725300\
    \ + 2^32,\n// where 2^32 is used to wrap around.\n// Note: we used 1073725300\
    \ instead of 1073725440 to avoid possible\n// edge cases.\n// 1 - 1073725300 +\
    \ 2^32 = 3221241997\n\n// Oops, old kernels happily accept this packet.\n+0 <\
    \ . 1:1001(1000) ack 3221241997 win 65535\n\n// After the kernel fix the following\
    \ will be replaced by a challenge ACK,\n// and prior malicious frame would be\
    \ dropped.\n+0 > . 1:1(0) ack 1001"
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: tcp:\
    \ no acepta ACK de bytes que nunca enviamos. Este parche se basa en un informe\
    \ detallado e ideas de Yepeng Pan y Christian Rossow. La validaci\xF3n de secuencia\
    \ de ACK sigue actualmente las pautas RFC 5961 5.2: El valor de ACK se considera\
    \ aceptable solo si est\xE1 en el rango de ((SND.UNA - MAX.SND.WND) &lt;= SEG.ACK\
    \ &lt;= SND.NXT). Todos los segmentos entrantes cuyo valor ACK no satisface la\
    \ condici\xF3n anterior DEBEN descartarse y enviarse un ACK. Es necesario tener\
    \ en cuenta que RFC 793 en la p\xE1gina 72 (quinta verificaci\xF3n) dice: \"Si\
    \ el ACK es un duplicado (SEG.ACK &lt; SND.UNA), se puede ignorar. Si el ACK reconoce\
    \ algo que a\xFAn no se ha enviado (SEG. ACK &gt; SND.NXT) luego env\xEDa un ACK,\
    \ descarta el segmento y regresa\". Lo \"ignorado\" anterior implica que el procesamiento\
    \ del segmento de datos entrantes contin\xFAa, lo que significa que el valor ACK\
    \ se trata como aceptable. Esta mitigaci\xF3n hace que la verificaci\xF3n de ACK\
    \ sea m\xE1s estricta, ya que no se aceptar\xE1 ning\xFAn ACK &lt; SND.UNA; en\
    \ su lugar, solo se aceptar\xE1n ACK que est\xE9n en el rango ((SND.UNA - MAX.SND.WND)\
    \ &lt;= SEG.ACK &lt;= SND. NXT) pasar. Esto se puede perfeccionar para flujos\
    \ nuevos (y posiblemente falsificados) al no aceptar ACK para bytes que nunca\
    \ se enviaron. Esto mejora enormemente la seguridad de TCP a un costo reducido.\
    \ Agregu\xE9 una etiqueta Correcciones: para asegurarme de que este parche llegue\
    \ a \xE1rboles estables, incluso si el parche \"culpado\" se adhiri\xF3 al RFC.\
    \ tp-&gt;bytes_acked se agreg\xF3 en Linux-4.2 La siguiente prueba de packagedrill\
    \ (cortes\xEDa de Yepeng Pan) muestra el problema en cuesti\xF3n: 0 socket(...,\
    \ SOCK_STREAM, IPPROTO_TCP) = 3 +0 setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1\
    \ ], 4) = 0 +0 enlazar(3, ..., ...) = 0 +0 escuchar(3, 1024) = 0 // ----------------\
    \ Apret\xF3n de manos ------------------- // // cuando la escala de la ventana\
    \ se establece en 14, el tama\xF1o de la ventana se puede ampliar a // 65535 *\
    \ (2^14) = 1073725440. Linux aceptar\xEDa un paquete ACK // con un n\xFAmero de\
    \ reconocimiento en (Server_ISN+1-1073725440. Server_ISN+1) //, aunque este n\xFA\
    mero de reconocimiento reconoce algunos datos // nunca enviados por el servidor.\
    \ +0 &lt; S 0:0(0) win 65535  +0 &gt; S. 0:0(0) ack 1 &lt;...&gt; +0 &lt; . 1:1(0)\
    \ ack 1 win 65535 +0 aceptar(3, ..., ...) = 4 // Para la conexi\xF3n establecida,\
    \ enviamos un paquete ACK, // el paquete de confirmaci\xF3n utiliza el n\xFAmero\
    \ de confirmaci\xF3n 1 - 1073725300 + 2^32, // donde 2^32 se usa para envolver.\
    \ // Nota: utilizamos 1073725300 en lugar de 1073725440 para evitar posibles //\
    \ casos extremos. // 1 - 1073725300 + 2^32 = 3221241997 // Vaya, los n\xFAcleos\
    \ antiguos aceptan felizmente este paquete. +0 &lt;. 1:1001(1000) ACK 3221241997\
    \ win 65535 // Despu\xE9s de la correcci\xF3n del kernel, lo siguiente ser\xE1\
    \ reemplazado por un ACK de desaf\xEDo, // y el marco malicioso anterior se eliminar\xE1\
    . +0 &gt; . 1:1(0) reconocimiento 1001"
id: CVE-2023-52881
lastModified: '2024-05-29T13:02:09.280'
metrics: {}
published: '2024-05-29T11:16:02.110'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/008b807fe487e0b15a3a6c39add4eb477f73e440
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/0d4e0afdd6658cd21dd5be61880411a2553fd1fc
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/2087d53a66e97a5eb5d1bf558d5bef9e5f891757
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/3d501dd326fb1c73f1b8206d4c6e1d7b15c07e27
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/458f07ffeccd17f99942311e09ef574ddf4a414a
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/69eae75ca5255e876628ac5cee9eaab31f644b57
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/7ffff0cc929fdfc62a74b384c4903d6496c910f0
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/b17a886ed29f3b70b78ccf632dad03e0c69e3c1a
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
