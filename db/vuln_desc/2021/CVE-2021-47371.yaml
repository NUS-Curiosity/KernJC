descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    nexthop: Fix memory leaks in nexthop notification chain listeners\n\nsyzkaller\
    \ discovered memory leaks [1] that can be reduced to the\nfollowing commands:\n\
    \n # ip nexthop add id 1 blackhole\n # devlink dev reload pci/0000:06:00.0\n\n\
    As part of the reload flow, mlxsw will unregister its netdevs and then\nunregister\
    \ from the nexthop notification chain. Before unregistering\nfrom the notification\
    \ chain, mlxsw will receive delete notifications for\nnexthop objects using netdevs\
    \ registered by mlxsw or their uppers. mlxsw\nwill not receive notifications for\
    \ nexthops using netdevs that are not\ndismantled as part of the reload flow.\
    \ For example, the blackhole\nnexthop above that internally uses the loopback\
    \ netdev as its nexthop\ndevice.\n\nOne way to fix this problem is to have listeners\
    \ flush their nexthop\ntables after unregistering from the notification chain.\
    \ This is\nerror-prone as evident by this patch and also not symmetric with the\n\
    registration path where a listener receives a dump of all the existing\nnexthops.\n\
    \nTherefore, fix this problem by replaying delete notifications for the\nlistener\
    \ being unregistered. This is symmetric to the registration path\nand also consistent\
    \ with the netdev notification chain.\n\nThe above means that unregister_nexthop_notifier(),\
    \ like\nregister_nexthop_notifier(), will have to take RTNL in order to iterate\n\
    over the existing nexthops and that any callers of the function cannot\nhold RTNL.\
    \ This is true for mlxsw and netdevsim, but not for the VXLAN\ndriver. To avoid\
    \ a deadlock, change the latter to unregister its nexthop\nlistener without holding\
    \ RTNL, making it symmetric to the registration\npath.\n\n[1]\nunreferenced object\
    \ 0xffff88806173d600 (size 512):\n  comm \"syz-executor.0\", pid 1290, jiffies\
    \ 4295583142 (age 143.507s)\n  hex dump (first 32 bytes):\n    41 9d 1e 60 80\
    \ 88 ff ff 08 d6 73 61 80 88 ff ff  A..`......sa....\n    08 d6 73 61 80 88 ff\
    \ ff 01 00 00 00 00 00 00 00  ..sa............\n  backtrace:\n    [<ffffffff81a6b576>]\
    \ kmemleak_alloc_recursive include/linux/kmemleak.h:43 [inline]\n    [<ffffffff81a6b576>]\
    \ slab_post_alloc_hook+0x96/0x490 mm/slab.h:522\n    [<ffffffff81a716d3>] slab_alloc_node\
    \ mm/slub.c:3206 [inline]\n    [<ffffffff81a716d3>] slab_alloc mm/slub.c:3214\
    \ [inline]\n    [<ffffffff81a716d3>] kmem_cache_alloc_trace+0x163/0x370 mm/slub.c:3231\n\
    \    [<ffffffff82e8681a>] kmalloc include/linux/slab.h:591 [inline]\n    [<ffffffff82e8681a>]\
    \ kzalloc include/linux/slab.h:721 [inline]\n    [<ffffffff82e8681a>] mlxsw_sp_nexthop_obj_group_create\
    \ drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c:4918 [inline]\n    [<ffffffff82e8681a>]\
    \ mlxsw_sp_nexthop_obj_new drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c:5054\
    \ [inline]\n    [<ffffffff82e8681a>] mlxsw_sp_nexthop_obj_event+0x59a/0x2910 drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c:5239\n\
    \    [<ffffffff813ef67d>] notifier_call_chain+0xbd/0x210 kernel/notifier.c:83\n\
    \    [<ffffffff813f0662>] blocking_notifier_call_chain kernel/notifier.c:318 [inline]\n\
    \    [<ffffffff813f0662>] blocking_notifier_call_chain+0x72/0xa0 kernel/notifier.c:306\n\
    \    [<ffffffff8384b9c6>] call_nexthop_notifiers+0x156/0x310 net/ipv4/nexthop.c:244\n\
    \    [<ffffffff83852bd8>] insert_nexthop net/ipv4/nexthop.c:2336 [inline]\n  \
    \  [<ffffffff83852bd8>] nexthop_add net/ipv4/nexthop.c:2644 [inline]\n    [<ffffffff83852bd8>]\
    \ rtm_new_nexthop+0x14e8/0x4d10 net/ipv4/nexthop.c:2913\n    [<ffffffff833e9a78>]\
    \ rtnetlink_rcv_msg+0x448/0xbf0 net/core/rtnetlink.c:5572\n    [<ffffffff83608703>]\
    \ netlink_rcv_skb+0x173/0x480 net/netlink/af_netlink.c:2504\n    [<ffffffff833de032>]\
    \ rtnetlink_rcv+0x22/0x30 net/core/rtnetlink.c:5590\n    [<ffffffff836069de>]\
    \ netlink_unicast_kernel net/netlink/af_netlink.c:1314 [inline]\n    [<ffffffff836069de>]\
    \ netlink_unicast+0x5ae/0x7f0 net/netlink/af_netlink.c:1340\n    [<ffffffff83607501>]\
    \ netlink_sendmsg+0x8e1/0xe30 net/netlink/af_netlink.c:1929\n    [<ffffffff832fde84>]\
    \ sock_sendmsg_nosec net/socket.c:704 [inline\n---truncated---"
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: nexthop:\
    \ corrige p\xE9rdidas de memoria en los oyentes de la cadena de notificaciones\
    \ de nexthop syzkaller descubri\xF3 p\xE9rdidas de memoria [1] que se pueden reducir\
    \ a los siguientes comandos: # ip nexthop add id 1 blackhole # devlink dev reload\
    \ pci /0000:06:00.0 Como parte del flujo de recarga, mlxsw cancelar\xE1 el registro\
    \ de sus netdevs y luego cancelar\xE1 el registro de la cadena de notificaci\xF3\
    n de nexthop. Antes de cancelar el registro de la cadena de notificaciones, mlxsw\
    \ recibir\xE1 notificaciones de eliminaci\xF3n de objetos de nexthop utilizando\
    \ netdevs registrados por mlxsw o sus superiores. mlxsw no recibir\xE1 notificaciones\
    \ de nexthops que utilicen netdevs que no est\xE9n desmantelados como parte del\
    \ flujo de recarga. Por ejemplo, el blackhole nexthop anterior que utiliza internamente\
    \ el loopback netdev como su dispositivo nexthop. Una forma de solucionar este\
    \ problema es hacer que los oyentes vac\xEDen sus tablas de nexthop despu\xE9\
    s de darse de baja de la cadena de notificaciones. Esto es propenso a errores,\
    \ como lo demuestra este parche, y tampoco es sim\xE9trico con la ruta de registro\
    \ donde un oyente recibe un volcado de todos los nexthops existentes. Por lo tanto,\
    \ solucione este problema reproduciendo las notificaciones de eliminaci\xF3n del\
    \ oyente que se est\xE1 cancelando el registro. Esto es sim\xE9trico a la ruta\
    \ de registro y tambi\xE9n consistente con la cadena de notificaci\xF3n de netdev.\
    \ Lo anterior significa que unregister_nexthop_notifier(), al igual que Register_nexthop_notifier(),\
    \ tendr\xE1 que tomar RTNL para poder iterar sobre los nexthops existentes y que\
    \ cualquier persona que llame a la funci\xF3n no puede mantener RTNL. Esto es\
    \ cierto para mlxsw y netdevsim, pero no para el controlador VXLAN. Para evitar\
    \ un punto muerto, cambie este \xFAltimo para cancelar el registro de su oyente\
    \ nexthop sin mantener presionado RTNL, haci\xE9ndolo sim\xE9trico a la ruta de\
    \ registro. [1] objeto sin referencia 0xffff88806173d600 (tama\xF1o 512): comm\
    \ \"syz-executor.0\", pid 1290, jiffies 4295583142 (edad 143.507s) volcado hexadecimal\
    \ (primeros 32 bytes): 41 9d 1e 60 80 88 ff ff 08 d6 73 1 80 88 ff ff A..`......sa....\
    \ 08 d6 73 61 80 88 ff ff 01 00 00 00 00 00 00 00 ..sa............ backtrace:\
    \ [] kmemleak_alloc_recursive include/linux/kmemleak.h:43 [en l\xEDnea] [] slab_post_alloc_hook+0x96/0x490\
    \ mm/slab.h:522 [] mm/slub.c:3206 [en l\xEDnea] [] slab_alloc mm/slub.c:3214 [en\
    \ l\xEDnea] [] kmem_cache_alloc_trace+0x163/0x370 mm/slub.c:3231 [] kmalloc include/linux/slab.h:\
    \ 591 [en l\xEDnea] [] kzalloc include/linux/slab.h:721 [en l\xEDnea] [] mlxsw_sp_nexthop_obj_group_create\
    \ drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c:4918 [ ] mlxsw_sp_nexthop_obj_new\
    \ drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c:5054 [en l\xEDnea] []\
    \ mlxsw_sp_nexthop_obj_event+0x59a/0x2910 drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c:523\
    \ 9 [] notifier_call_chain+0xbd/0x210 kernel/notifier.c:83 [] blocking_notifier_call_chain\
    \ kernel/notifier.c:318 [en l\xEDnea] [] blocking_notifier_call_chain+0x72/0xa0\
    \ kernel/notifier.c:306 [] call_nexthop_notifiers+0x156/0x310 net/ipv4/nexthop.c:244\
    \ [] insert_nexthop net/ipv4/nexthop.c:2336 [en l\xEDnea] [] nexthop_add net/ipv4/nexthop.c:2644\
    \ [en l\xEDnea] [] rtm_new_nexthop+0x14e8/0x4d10 net/ipv4/nexthop.c:2913 [] rtnetlink_rcv_msg+0x448/0xbf0\
    \ net/core/rtnetlink.c:5572 [ ] netlink_rcv_skb+0x173/0x480 neto/ netlink/af_netlink.c:\
    \ 2504 [] rtnetlink_rcv+0x22/0x30 net/core/rtnetlink.c: 5590 [] netlink_unicast_kernel\
    \ net/netlink/af_fffffff.c: 1314 [faff. 6069de&gt;] netlink_unicast +0x5ae/0x7f0\
    \ net/netlink/af_netlink.c:1340 [] --- truncado--"
id: CVE-2021-47371
lastModified: '2024-05-21T16:54:26.047'
metrics: {}
published: '2024-05-21T15:15:23.000'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/3106a0847525befe3e22fc723909d1b21eb0d520
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/741760fa6252628a3d3afad439b72437d4b123d9
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
