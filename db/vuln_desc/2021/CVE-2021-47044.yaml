cveTags: []
descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    sched/fair: Fix shift-out-of-bounds in load_balance()\n\nSyzbot reported a handful\
    \ of occurrences where an sd->nr_balance_failed can\ngrow to much higher values\
    \ than one would expect.\n\nA successful load_balance() resets it to 0; a failed\
    \ one increments\nit. Once it gets to sd->cache_nice_tries + 3, this *should*\
    \ trigger an\nactive balance, which will either set it to sd->cache_nice_tries+1\
    \ or reset\nit to 0. However, in case the to-be-active-balanced task is not allowed\
    \ to\nrun on env->dst_cpu, then the increment is done without any further\nmodification.\n\
    \nThis could then be repeated ad nauseam, and would explain the absurdly high\n\
    values reported by syzbot (86, 149). VincentG noted there is value in\nletting\
    \ sd->cache_nice_tries grow, so the shift itself should be\nfixed. That means\
    \ preventing:\n\n  \"\"\"\n  If the value of the right operand is negative or\
    \ is greater than or equal\n  to the width of the promoted left operand, the behavior\
    \ is undefined.\n  \"\"\"\n\nThus we need to cap the shift exponent to\n  BITS_PER_TYPE(typeof(lefthand))\
    \ - 1.\n\nI had a look around for other similar cases via coccinelle:\n\n  @expr@\n\
    \  position pos;\n  expression E1;\n  expression E2;\n  @@\n  (\n  E1 >> E2@pos\n\
    \  |\n  E1 >> E2@pos\n  )\n\n  @cst depends on expr@\n  position pos;\n  expression\
    \ expr.E1;\n  constant cst;\n  @@\n  (\n  E1 >> cst@pos\n  |\n  E1 << cst@pos\n\
    \  )\n\n  @script:python depends on !cst@\n  pos << expr.pos;\n  exp << expr.E2;\n\
    \  @@\n  # Dirty hack to ignore constexpr\n  if exp.upper() != exp:\n     coccilib.report.print_report(pos[0],\
    \ \"Possible UB shift here\")\n\nThe only other match in kernel/sched is rq_clock_thermal()\
    \ which employs\nsched_thermal_decay_shift, and that exponent is already capped\
    \ to 10, so\nthat one is fine."
- lang: es
  value: "En el kernel de Linux, se resolvi\xF3 la siguiente vulnerabilidad: sched/fair:\
    \ corrigi\xF3 el desplazamiento fuera de los l\xEDmites en load_balance() Syzbot\
    \ inform\xF3 sobre varios casos en los que sd-&gt;nr_balance_failed puede crecer\
    \ a valores mucho m\xE1s altos de lo que uno esperar\xEDa. . Un load_balance()\
    \ exitoso lo restablece a 0; uno fallido lo incrementa. Una vez que llegue a sd-&gt;cache_nice_tries\
    \ + 3, esto *deber\xEDa* activar un saldo activo, que lo establecer\xE1 en sd-&gt;cache_nice_tries+1\
    \ o lo restablecer\xE1 a 0. Sin embargo, en caso de que el saldo est\xE9 activo\
    \ La tarea no puede ejecutarse en env-&gt;dst_cpu, entonces el incremento se realiza\
    \ sin ninguna modificaci\xF3n adicional. Esto podr\xEDa repetirse hasta la saciedad\
    \ y explicar\xEDa los valores absurdamente altos informados por syzbot (86, 149).\
    \ VincentG se\xF1al\xF3 que es valioso dejar que sd-&gt;cache_nice_tries crezca,\
    \ por lo que el cambio en s\xED deber\xEDa corregirse. Eso significa evitar: \"\
    \"\" Si el valor del operando derecho es negativo o es mayor o igual que el ancho\
    \ del operando izquierdo promocionado, el comportamiento no est\xE1 definido.\
    \ \"\"\" Por lo tanto, debemos limitar el exponente de desplazamiento a BITS_PER_TYPE(\
    \ typeof(lefthand)) - 1. Ech\xE9 un vistazo a otros casos similares a trav\xE9\
    s de coccinelle: @expr@ position pos; expresi\xF3n E1; expresi\xF3n E2; @@ ( E1\
    \ &gt;&gt; E2@pos | E1 &gt;&gt; E2@pos ) @cst depende de expr@ posici\xF3n pos;\
    \ expresi\xF3n expr.E1; cst constante; @@ ( E1 &gt;&gt; cst@pos | E1 &lt;&lt;\
    \ cst@pos ) @script:python depende de !cst@ pos &lt;&lt; expr.pos; exp &lt;&lt;\
    \ expr.E2; @@ # Truco sucio para ignorar constexpr if exp.upper() != exp: coccilib.report.print_report(pos[0],\
    \ \"Posible cambio de UB aqu\xED\") La \xFAnica otra coincidencia en kernel/sched\
    \ es rq_clock_thermal() que emplea sched_thermal_decay_shift, y ese exponente\
    \ ya est\xE1 limitado a 10, por lo que ese est\xE1 bien."
id: CVE-2021-47044
lastModified: '2024-02-28T14:06:45.783'
metrics: {}
published: '2024-02-28T09:15:40.173'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/2f3eab368e313dba35fc2f51ede778bf7b030b54
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/39a2a6eb5c9b66ea7c8055026303b3aa681b49a5
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/805cea93e66ca7deaaf6ad3b67224ce47c104c2f
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/80862cbf76c2646f709a57c4517aefe0b094c774
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
