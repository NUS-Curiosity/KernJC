descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    KVM: x86/mmu: x86: Don't overflow lpage_info when checking attributes\n\nFix KVM_SET_MEMORY_ATTRIBUTES\
    \ to not overflow lpage_info array and trigger\nKASAN splat, as seen in the private_mem_conversions_test\
    \ selftest.\n\nWhen memory attributes are set on a GFN range, that range will\
    \ have\nspecific properties applied to the TDP. A huge page cannot be used when\n\
    the attributes are inconsistent, so they are disabled for those the\nspecific\
    \ huge pages. For internal KVM reasons, huge pages are also not\nallowed to span\
    \ adjacent memslots regardless of whether the backing memory\ncould be mapped\
    \ as huge.\n\nWhat GFNs support which huge page sizes is tracked by an array of\
    \ arrays\n'lpage_info' on the memslot, of \u2018kvm_lpage_info\u2019 structs.\
    \ Each index of\nlpage_info contains a vmalloc allocated array of these for a\
    \ specific\nsupported page size. The kvm_lpage_info denotes whether a specific\
    \ huge\npage (GFN and page size) on the memslot is supported. These arrays include\n\
    indices for unaligned head and tail huge pages.\n\nPreventing huge pages from\
    \ spanning adjacent memslot is covered by\nincrementing the count in head and\
    \ tail kvm_lpage_info when the memslot is\nallocated, but disallowing huge pages\
    \ for memory that has mixed attributes\nhas to be done in a more complicated way.\
    \ During the\nKVM_SET_MEMORY_ATTRIBUTES ioctl KVM updates lpage_info for each\
    \ memslot in\nthe range that has mismatched attributes. KVM does this a memslot\
    \ at a\ntime, and marks a special bit, KVM_LPAGE_MIXED_FLAG, in the kvm_lpage_info\n\
    for any huge page. This bit is essentially a permanently elevated count.\nSo huge\
    \ pages will not be mapped for the GFN at that page size if the\ncount is elevated\
    \ in either case: a huge head or tail page unaligned to\nthe memslot or if KVM_LPAGE_MIXED_FLAG\
    \ is set because it has mixed\nattributes.\n\nTo determine whether a huge page\
    \ has consistent attributes, the\nKVM_SET_MEMORY_ATTRIBUTES operation checks an\
    \ xarray to make sure it\nconsistently has the incoming attribute. Since level\
    \ - 1 huge pages are\naligned to level huge pages, it employs an optimization.\
    \ As long as the\nlevel - 1 huge pages are checked first, it can just check these\
    \ and assume\nthat if each level - 1 huge page contained within the level sized\
    \ huge\npage is not mixed, then the level size huge page is not mixed. This\n\
    optimization happens in the helper hugepage_has_attrs().\n\nUnfortunately, although\
    \ the kvm_lpage_info array representing page size\n'level' will contain an entry\
    \ for an unaligned tail page of size level,\nthe array for level - 1  will not\
    \ contain an entry for each GFN at page\nsize level. The level - 1 array will\
    \ only contain an index for any\nunaligned region covered by level - 1 huge page\
    \ size, which can be a\nsmaller region. So this causes the optimization to overflow\
    \ the level - 1\nkvm_lpage_info and perform a vmalloc out of bounds read.\n\n\
    In some cases of head and tail pages where an overflow could happen,\ncallers\
    \ skip the operation completely as KVM_LPAGE_MIXED_FLAG is not\nrequired to prevent\
    \ huge pages as discussed earlier. But for memslots that\nare smaller than the\
    \ 1GB page size, it does call hugepage_has_attrs(). In\nthis case the huge page\
    \ is both the head and tail page. The issue can be\nobserved simply by compiling\
    \ the kernel with CONFIG_KASAN_VMALLOC and\nrunning the selftest \u201Cprivate_mem_conversions_test\u201D\
    , which produces the\noutput like the following:\n\nBUG: KASAN: vmalloc-out-of-bounds\
    \ in hugepage_has_attrs+0x7e/0x110\nRead of size 4 at addr ffffc900000a3008 by\
    \ task private_mem_con/169\nCall Trace:\n  dump_stack_lvl\n  print_report\n  ?\
    \ __virt_addr_valid\n  ? hugepage_has_attrs\n  ? hugepage_has_attrs\n  kasan_report\n\
    \  ? hugepage_has_attrs\n  hugepage_has_attrs\n  kvm_arch_post_set_memory_attributes\n\
    \  kvm_vm_ioctl\n\nIt is a little ambiguous whether the unaligned head page (in\
    \ the bug case\nalso the tail page) should be expected to have KVM_LPAGE_MIXED_FLAG\
    \ set.\nIt is not functionally required, as the unal\n---truncated---"
- lang: es
  value: "En el kernel de Linux, se resolvi\xF3 la siguiente vulnerabilidad: KVM:\
    \ x86/mmu: x86: no desborde lpage_info al verificar los atributos. Corrija KVM_SET_MEMORY_ATTRIBUTES\
    \ para no desbordar la matriz lpage_info y activar KASAN splat, como se ve en\
    \ la autoprueba private_mem_conversions_test. Cuando los atributos de memoria\
    \ se configuran en un rango GFN, ese rango tendr\xE1 propiedades espec\xEDficas\
    \ aplicadas al TDP. No se puede utilizar una p\xE1gina enorme cuando los atributos\
    \ son inconsistentes, por lo que est\xE1n deshabilitados para aquellas p\xE1ginas\
    \ enormes espec\xEDficas. Por razones internas de KVM, tampoco se permite que\
    \ p\xE1ginas grandes abarquen ranuras de memoria adyacentes, independientemente\
    \ de si la memoria de respaldo podr\xEDa asignarse como enorme. Qu\xE9 GFN admite\
    \ qu\xE9 tama\xF1os de p\xE1gina enormes se rastrea mediante una serie de matrices\
    \ 'lpage_info' en el memslot, de estructuras 'kvm_lpage_info'. Cada \xEDndice\
    \ de lpage_info contiene una matriz asignada por vmalloc para un tama\xF1o de\
    \ p\xE1gina compatible espec\xEDfico. kvm_lpage_info indica si se admite una p\xE1\
    gina enorme espec\xEDfica (GFN y tama\xF1o de p\xE1gina) en la ranura de memoria.\
    \ Estas matrices incluyen \xEDndices para p\xE1ginas grandes de cabecera y cola\
    \ no alineadas. Para evitar que p\xE1ginas grandes abarquen ranuras de memoria\
    \ adyacentes, se incrementa el recuento en head y tail kvm_lpage_info cuando se\
    \ asigna la ranura de memoria, pero no permitir p\xE1ginas grandes para memoria\
    \ que tenga atributos mixtos debe hacerse de una manera m\xE1s complicada. Durante\
    \ KVM_SET_MEMORY_ATTRIBUTES ioctl, KVM actualiza lpage_info para cada ranura de\
    \ memoria en el rango que tiene atributos que no coinciden. KVM hace esto una\
    \ ranura de memoria a la vez y marca un bit especial, KVM_LPAGE_MIXED_FLAG, en\
    \ kvm_lpage_info para cualquier p\xE1gina grande. Este bit es esencialmente un\
    \ recuento elevado permanentemente. Por lo tanto, las p\xE1ginas grandes no se\
    \ asignar\xE1n para GFN en ese tama\xF1o de p\xE1gina si el recuento es elevado\
    \ en cualquier caso: una p\xE1gina principal o final enorme no alineada con la\
    \ ranura de memoria o si KVM_LPAGE_MIXED_FLAG est\xE1 configurado porque tiene\
    \ atributos mixtos. Para determinar si una p\xE1gina enorme tiene atributos consistentes,\
    \ la operaci\xF3n KVM_SET_MEMORY_ATTRIBUTES verifica una matriz x para asegurarse\
    \ de que tenga consistentemente el atributo entrante. Dado que las p\xE1ginas\
    \ grandes de nivel 1 est\xE1n alineadas con las p\xE1ginas grandes de nivel, se\
    \ emplea una optimizaci\xF3n. Siempre que se verifiquen primero las p\xE1ginas\
    \ grandes de nivel - 1, puede simplemente verificarlas y asumir que si cada p\xE1\
    gina enorme de nivel - 1 contenida dentro de la p\xE1gina enorme de tama\xF1o\
    \ de nivel no est\xE1 mezclada, entonces la p\xE1gina enorme de tama\xF1o de nivel\
    \ no est\xE1 mezclada. Esta optimizaci\xF3n ocurre en el ayudante Hugepage_has_attrs().\
    \ Desafortunadamente, aunque la matriz kvm_lpage_info que representa el tama\xF1\
    o de p\xE1gina 'nivel' contendr\xE1 una entrada para una p\xE1gina final no alineada\
    \ de nivel de tama\xF1o, la matriz para el nivel - 1 no contendr\xE1 una entrada\
    \ para cada GFN en el nivel de tama\xF1o de p\xE1gina. La matriz de nivel 1 solo\
    \ contendr\xE1 un \xEDndice para cualquier regi\xF3n no alineada cubierta por\
    \ el tama\xF1o de p\xE1gina enorme de nivel 1, que puede ser una regi\xF3n m\xE1\
    s peque\xF1a. Entonces, esto hace que la optimizaci\xF3n desborde el nivel - 1\
    \ kvm_lpage_info y realice una lectura vmalloc fuera de los l\xEDmites. En algunos\
    \ casos de p\xE1ginas principales y finales donde podr\xEDa ocurrir un desbordamiento,\
    \ las personas que llaman omiten la operaci\xF3n por completo ya que KVM_LPAGE_MIXED_FLAG\
    \ no es necesario para evitar p\xE1ginas grandes como se analiz\xF3 anteriormente.\
    \ Pero para las ranuras de memoria que son m\xE1s peque\xF1as que el tama\xF1\
    o de p\xE1gina de 1 GB, llama a hugepage_has_attrs(). En este caso, la p\xE1gina\
    \ enorme es tanto la p\xE1gina principal como la final. --truncado---"
id: CVE-2024-26991
lastModified: '2024-05-13T08:15:11.137'
metrics: {}
published: '2024-05-01T06:15:16.820'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/048cc4a028e635d339687ed968985d2d1669494c
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/992b54bd083c5bee24ff7cc35991388ab08598c4
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
