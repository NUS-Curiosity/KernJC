descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    usb: gadget: f_fs: Fix race between aio_cancel() and AIO request complete\n\n\
    FFS based applications can utilize the aio_cancel() callback to dequeue\npending\
    \ USB requests submitted to the UDC.  There is a scenario where the\nFFS application\
    \ issues an AIO cancel call, while the UDC is handling a\nsoft disconnect.  For\
    \ a DWC3 based implementation, the callstack looks\nlike the following:\n\n  \
    \  DWC3 Gadget                               FFS Application\ndwc3_gadget_soft_disconnect()\
    \              ...\n  --> dwc3_stop_active_transfers()\n    --> dwc3_gadget_giveback(-ESHUTDOWN)\n\
    \      --> ffs_epfile_async_io_complete()   ffs_aio_cancel()\n        --> usb_ep_free_request()\
    \            --> usb_ep_dequeue()\n\nThere is currently no locking implemented\
    \ between the AIO completion\nhandler and AIO cancel, so the issue occurs if the\
    \ completion routine is\nrunning in parallel to an AIO cancel call coming from\
    \ the FFS application.\nAs the completion call frees the USB request (io_data->req)\
    \ the FFS\napplication is also referencing it for the usb_ep_dequeue() call. \
    \ This can\nlead to accessing a stale/hanging pointer.\n\ncommit b566d38857fc\
    \ (\"usb: gadget: f_fs: use io_data->status consistently\")\nrelocated the usb_ep_free_request()\
    \ into ffs_epfile_async_io_complete().\nHowever, in order to properly implement\
    \ locking to mitigate this issue, the\nspinlock can't be added to ffs_epfile_async_io_complete(),\
    \ as\nusb_ep_dequeue() (if successfully dequeuing a USB request) will call the\n\
    function driver's completion handler in the same context.  Hence, leading\ninto\
    \ a deadlock.\n\nFix this issue by moving the usb_ep_free_request() back to\n\
    ffs_user_copy_worker(), and ensuring that it explicitly sets io_data->req\nto\
    \ NULL after freeing it within the ffs->eps_lock.  This resolves the race\ncondition\
    \ above, as the ffs_aio_cancel() routine will not continue\nattempting to dequeue\
    \ a request that has already been freed, or the\nffs_user_copy_work() not freeing\
    \ the USB request until the AIO cancel is\ndone referencing it.\n\nThis fix depends\
    \ on\n  commit b566d38857fc (\"usb: gadget: f_fs: use io_data->status\n  consistently\"\
    )"
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: usb:\
    \ gadget: f_fs: corrige la ejecuci\xF3n entre aio_cancel() y la solicitud AIO.\
    \ Las aplicaciones basadas en FFS completas pueden utilizar la devoluci\xF3n de\
    \ llamada aio_cancel() para quitar de la cola las solicitudes USB pendientes enviadas\
    \ al UDC. Existe un escenario en el que la aplicaci\xF3n FFS emite una llamada\
    \ de cancelaci\xF3n de AIO, mientras el UDC maneja una desconexi\xF3n suave. Para\
    \ una implementaci\xF3n basada en DWC3, la pila de llamadas se parece a la siguiente:\
    \ Aplicaci\xF3n DWC3 Gadget FFS dwc3_gadget_soft_disconnect() ... --&gt; dwc3_stop_active_transfers()\
    \ --&gt; dwc3_gadget_giveback(-ESHUTDOWN) --&gt; ffs_epfile_async_io_complete()\
    \ ffs_aio_cancel() --&gt; usb_ep_free_request () --&gt; usb_ep_dequeue() Actualmente\
    \ no hay ning\xFAn bloqueo implementado entre el controlador de finalizaci\xF3\
    n de AIO y la cancelaci\xF3n de AIO, por lo que el problema ocurre si la rutina\
    \ de finalizaci\xF3n se ejecuta en paralelo a una llamada de cancelaci\xF3n de\
    \ AIO proveniente de la aplicaci\xF3n FFS. A medida que la llamada de finalizaci\xF3\
    n libera la solicitud USB (io_data-&gt;req), la aplicaci\xF3n FFS tambi\xE9n hace\
    \ referencia a ella para la llamada usb_ep_dequeue(). Esto puede llevar a acceder\
    \ a un puntero obsoleto/colgado. commit b566d38857fc (\"usb: gadget: f_fs: use\
    \ io_data-&gt;status consistentemente\") reubic\xF3 usb_ep_free_request() en ffs_epfile_async_io_complete().\
    \ Sin embargo, para implementar correctamente el bloqueo para mitigar este problema,\
    \ el spinlock no se puede agregar a ffs_epfile_async_io_complete(), ya que usb_ep_dequeue()\
    \ (si se elimina con \xE9xito una solicitud USB) llamar\xE1 al controlador de\
    \ finalizaci\xF3n del controlador de funci\xF3n en el mismo contexto. De ah\xED\
    \ que se llegue a un punto muerto. Solucione este problema moviendo usb_ep_free_request()\
    \ de nuevo a ffs_user_copy_worker() y asegur\xE1ndose de que establezca expl\xED\
    citamente io_data-&gt;req en NULL despu\xE9s de liberarlo dentro de ffs-&gt;eps_lock.\
    \ Esto resuelve la condici\xF3n de ejecuci\xF3n anterior, ya que la rutina ffs_aio_cancel()\
    \ no continuar\xE1 intentando sacar de la cola una solicitud que ya ha sido liberada,\
    \ o ffs_user_copy_work() no liberar\xE1 la solicitud USB hasta que la cancelaci\xF3\
    n de AIO termine de hacer referencia a ella. Esta soluci\xF3n depende de el commit\
    \ b566d38857fc (\"usb: gadget: f_fs: use io_data-&gt;status consistentemente\"\
    )"
id: CVE-2024-36894
lastModified: '2024-06-21T14:15:12.163'
metrics: {}
published: '2024-05-30T16:15:12.857'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/24729b307eefcd7c476065cd7351c1a018082c19
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/73c05ad46bb4fbbdb346004651576d1c8dbcffbb
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/a0fdccb1c9e027e3195f947f61aa87d6d0d2ea14
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/d7461830823242702f5d84084bcccb25159003f4
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
