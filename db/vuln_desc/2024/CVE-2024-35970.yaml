descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    af_unix: Clear stale u->oob_skb.\n\nsyzkaller started to report deadlock of unix_gc_lock\
    \ after commit\n4090fa373f0e (\"af_unix: Replace garbage collection algorithm.\"\
    ), but\nit just uncovers the bug that has been there since commit 314001f0bf92\n\
    (\"af_unix: Add OOB support\").\n\nThe repro basically does the following.\n\n\
    \  from socket import *\n  from array import array\n\n  c1, c2 = socketpair(AF_UNIX,\
    \ SOCK_STREAM)\n  c1.sendmsg([b'a'], [(SOL_SOCKET, SCM_RIGHTS, array(\"i\", [c2.fileno()]))],\
    \ MSG_OOB)\n  c2.recv(1)  # blocked as no normal data in recv queue\n\n  c2.close()\
    \  # done async and unblock recv()\n  c1.close()  # done async and trigger GC\n\
    \nA socket sends its file descriptor to itself as OOB data and tries to\nreceive\
    \ normal data, but finally recv() fails due to async close().\n\nThe problem here\
    \ is wrong handling of OOB skb in manage_oob().  When\nrecvmsg() is called without\
    \ MSG_OOB, manage_oob() is called to check\nif the peeked skb is OOB skb.  In\
    \ such a case, manage_oob() pops it\nout of the receive queue but does not clear\
    \ unix_sock(sk)->oob_skb.\nThis is wrong in terms of uAPI.\n\nLet's say we send\
    \ \"hello\" with MSG_OOB, and \"world\" without MSG_OOB.\nThe 'o' is handled as\
    \ OOB data.  When recv() is called twice without\nMSG_OOB, the OOB data should\
    \ be lost.\n\n  >>> from socket import *\n  >>> c1, c2 = socketpair(AF_UNIX, SOCK_STREAM,\
    \ 0)\n  >>> c1.send(b'hello', MSG_OOB)  # 'o' is OOB data\n  5\n  >>> c1.send(b'world')\n\
    \  5\n  >>> c2.recv(5)  # OOB data is not received\n  b'hell'\n  >>> c2.recv(5)\
    \  # OOB date is skipped\n  b'world'\n  >>> c2.recv(5, MSG_OOB)  # This should\
    \ return an error\n  b'o'\n\nIn the same situation, TCP actually returns -EINVAL\
    \ for the last\nrecv().\n\nAlso, if we do not clear unix_sk(sk)->oob_skb, unix_poll()\
    \ always set\nEPOLLPRI even though the data has passed through by previous recv().\n\
    \nTo avoid these issues, we must clear unix_sk(sk)->oob_skb when dequeuing\nit\
    \ from recv queue.\n\nThe reason why the old GC did not trigger the deadlock is\
    \ because the\nold GC relied on the receive queue to detect the loop.\n\nWhen\
    \ it is triggered, the socket with OOB data is marked as GC candidate\nbecause\
    \ file refcount == inflight count (1).  However, after traversing\nall inflight\
    \ sockets, the socket still has a positive inflight count (1),\nthus the socket\
    \ is excluded from candidates.  Then, the old GC lose the\nchance to garbage-collect\
    \ the socket.\n\nWith the old GC, the repro continues to create true garbage that\
    \ will\nnever be freed nor detected by kmemleak as it's linked to the global\n\
    inflight list.  That's why we couldn't even notice the issue."
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: af_unix:\
    \ Borrar u-&gt;oob_skb obsoleto. syzkaller comenz\xF3 a informar un punto muerto\
    \ de unix_gc_lock despu\xE9s de la confirmaci\xF3n 4090fa373f0e (\"af_unix: Reemplazar\
    \ el algoritmo de recolecci\xF3n de basura\"), pero simplemente descubre el error\
    \ que ha estado ah\xED desde la confirmaci\xF3n 314001f0bf92 (\"af_unix: Agregar\
    \ soporte OOB\"). La reproducci\xF3n b\xE1sicamente hace lo siguiente. desde importaci\xF3\
    n de socket * desde matriz de importaci\xF3n matriz c1, c2 = socketpair(AF_UNIX,\
    \ SOCK_STREAM) c1.sendmsg([b'a'], [(SOL_SOCKET, SCM_RIGHTS, array(\"i\", [c2.fileno()]))\
    \ ], MSG_OOB) c2.recv(1) # bloqueado porque no hay datos normales en la cola de\
    \ recepci\xF3n c2.close() # hecho as\xEDncrono y desbloquea recv() c1.close()\
    \ # hecho as\xEDncrono y activa GC Un socket env\xEDa su descriptor de archivo\
    \ a como datos OOB e intenta recibir datos normales, pero finalmente recv() falla\
    \ debido al cierre as\xEDncrono(). El problema aqu\xED es el manejo incorrecto\
    \ de OOB skb en Manage_oob(). Cuando se llama a recvmsg() sin MSG_OOB, se llama\
    \ a Manage_oob() para verificar si el skb visto es skb OOB. En tal caso, Manage_oob()\
    \ lo saca de la cola de recepci\xF3n pero no borra unix_sock(sk)-&gt;oob_skb.\
    \ Esto est\xE1 mal en t\xE9rminos de uAPI. Digamos que enviamos \"hola\" con MSG_OOB\
    \ y \"mundo\" sin MSG_OOB. La 'o' se maneja como datos OOB. Cuando se llama a\
    \ recv() dos veces sin MSG_OOB, los datos OOB deber\xEDan perderse. &gt;&gt;&gt;\
    \ desde importaci\xF3n de socket * &gt;&gt;&gt; c1, c2 = socketpair(AF_UNIX, SOCK_STREAM,\
    \ 0) &gt;&gt;&gt; c1.send(b'hello', MSG_OOB) # 'o' son datos OOB 5 &gt;&gt;&gt;\
    \ c1.send (b'world') 5 &gt;&gt;&gt; c2.recv(5) # Los datos OOB no se reciben b'hell'\
    \ &gt;&gt;&gt; c2.recv(5) # La fecha OOB se omite b'world' &gt;&gt;&gt; c2.recv\
    \ (5, MSG_OOB) # Esto deber\xEDa devolver un error b'o'. En la misma situaci\xF3\
    n, TCP en realidad devuelve -EINVAL para el \xFAltimo recv(). Adem\xE1s, si no\
    \ borramos unix_sk(sk)-&gt;oob_skb, unix_poll() siempre establece EPOLLPRI aunque\
    \ los datos hayan pasado por el recv() anterior. Para evitar estos problemas,\
    \ debemos borrar unix_sk(sk)-&gt;oob_skb al retirarlo de la cola de recepci\xF3\
    n. La raz\xF3n por la que el antiguo GC no provoc\xF3 el punto muerto es porque\
    \ el antiguo GC depend\xEDa de la cola de recepci\xF3n para detectar el bucle.\
    \ Cuando se activa, el socket con datos OOB se marca como candidato de GC porque\
    \ el recuento de archivos == recuento en vuelo (1). Sin embargo, despu\xE9s de\
    \ atravesar todos los sockets en vuelo, el socket todav\xEDa tiene un recuento\
    \ positivo en vuelo (1), por lo que el socket queda excluido de los candidatos.\
    \ Entonces, el antiguo GC pierde la oportunidad de recolectar basura en el socket.\
    \ Con el antiguo GC, la reproducci\xF3n contin\xFAa creando verdadera basura que\
    \ kmemleak nunca liberar\xE1 ni detectar\xE1, ya que est\xE1 vinculada a la lista\
    \ global a bordo. Por eso ni siquiera pudimos notar el problema."
id: CVE-2024-35970
lastModified: '2024-05-20T13:00:04.957'
metrics: {}
published: '2024-05-20T10:15:11.860'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/601a89ea24d05089debfa2dc896ea9f5937ac7a6
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/698a95ade1a00e6494482046902b986dfffd1caf
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/84a352b7eba1142a95441380058985ff19f25ec9
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/b46f4eaa4f0ec38909fb0072eea3aeddb32f954e
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/b4bc99d04c689b5652665394ae8d3e02fb754153
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
