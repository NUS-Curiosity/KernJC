cveTags: []
descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    mm/swap: fix race when skipping swapcache\n\nWhen skipping swapcache for SWP_SYNCHRONOUS_IO,\
    \ if two or more threads\nswapin the same entry at the same time, they get different\
    \ pages (A, B). \nBefore one thread (T0) finishes the swapin and installs page\
    \ (A) to the\nPTE, another thread (T1) could finish swapin of page (B), swap_free\
    \ the\nentry, then swap out the possibly modified page reusing the same entry.\
    \ \nIt breaks the pte_same check in (T0) because PTE value is unchanged,\ncausing\
    \ ABA problem.  Thread (T0) will install a stalled page (A) into the\nPTE and\
    \ cause data corruption.\n\nOne possible callstack is like this:\n\nCPU0     \
    \                            CPU1\n----                                 ----\n\
    do_swap_page()                       do_swap_page() with same entry\n<direct swapin\
    \ path>                 <direct swapin path>\n<alloc page A>                 \
    \      <alloc page B>\nswap_read_folio() <- read to page A  swap_read_folio()\
    \ <- read to page B\n<slow on later locks or interrupt>   <finished swapin first>\n\
    ...                                  set_pte_at()\n                          \
    \           swap_free() <- entry is free\n                                   \
    \  <write to page B, now page A stalled>\n                                   \
    \  <swap out page B to same swap entry>\npte_same() <- Check pass, PTE seems\n\
    \              unchanged, but page A\n              is stalled!\nswap_free() <-\
    \ page B content lost!\nset_pte_at() <- staled page A installed!\n\nAnd besides,\
    \ for ZRAM, swap_free() allows the swap device to discard the\nentry content,\
    \ so even if page (B) is not modified, if swap_read_folio()\non CPU0 happens later\
    \ than swap_free() on CPU1, it may also cause data\nloss.\n\nTo fix this, reuse\
    \ swapcache_prepare which will pin the swap entry using\nthe cache flag, and allow\
    \ only one thread to swap it in, also prevent any\nparallel code from putting\
    \ the entry in the cache.  Release the pin after\nPT unlocked.\n\nRacers just\
    \ loop and wait since it's a rare and very short event.  A\nschedule_timeout_uninterruptible(1)\
    \ call is added to avoid repeated page\nfaults wasting too much CPU, causing livelock\
    \ or adding too much noise to\nperf statistics.  A similar livelock issue was\
    \ described in commit\n029c4628b2eb (\"mm: swap: get rid of livelock in swapin\
    \ readahead\")\n\nReproducer:\n\nThis race issue can be triggered easily using\
    \ a well constructed\nreproducer and patched brd (with a delay in read path) [1]:\n\
    \nWith latest 6.8 mainline, race caused data loss can be observed easily:\n$ gcc\
    \ -g -lpthread test-thread-swap-race.c && ./a.out\n  Polulating 32MB of memory\
    \ region...\n  Keep swapping out...\n  Starting round 0...\n  Spawning 65536 workers...\n\
    \  32746 workers spawned, wait for done...\n  Round 0: Error on 0x5aa00, expected\
    \ 32746, got 32743, 3 data loss!\n  Round 0: Error on 0x395200, expected 32746,\
    \ got 32743, 3 data loss!\n  Round 0: Error on 0x3fd000, expected 32746, got 32737,\
    \ 9 data loss!\n  Round 0 Failed, 15 data loss!\n\nThis reproducer spawns multiple\
    \ threads sharing the same memory region\nusing a small swap device.  Every two\
    \ threads updates mapped pages one by\none in opposite direction trying to create\
    \ a race, with one dedicated\nthread keep swapping out the data out using madvise.\n\
    \nThe reproducer created a reproduce rate of about once every 5 minutes, so\n\
    the race should be totally possible in production.\n\nAfter this patch, I ran\
    \ the reproducer for over a few hundred rounds and\nno data loss observed.\n\n\
    Performance overhead is minimal, microbenchmark swapin 10G from 32G\nzram:\n\n\
    Before:     10934698 us\nAfter:      11157121 us\nCached:     13155355 us (Dropping\
    \ SWP_SYNCHRONOUS_IO flag)\n\n[kasong@tencent.com: v4]\n  Link: https://lkml.kernel.org/r/20240219082040.7495-1-ryncsn@gmail.com"
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mm/swap:\
    \ corrige la ejecuci\xF3n al omitir swapcache Al omitir swapcache para SWP_SYNCHRONOUS_IO,\
    \ si dos o m\xE1s subprocesos intercambian la misma entrada al mismo tiempo, obtienen\
    \ p\xE1ginas diferentes (A, B) . Antes de que un subproceso (T0) finalice el intercambio\
    \ e instale la p\xE1gina (A) en el PTE, otro subproceso (T1) podr\xEDa finalizar\
    \ el intercambio de la p\xE1gina (B), liberar la entrada y luego intercambiar\
    \ la p\xE1gina posiblemente modificada reutilizando la misma entrada. Rompe el\
    \ control pte_same (T0) porque el valor de PTE no cambia, lo que provoca un problema\
    \ de ABA. El subproceso (T0) instalar\xE1 una p\xE1gina bloqueada (A) en el PTE\
    \ y provocar\xE1 da\xF1os en los datos. Una posible pila de llamadas es as\xED\
    : CPU0 CPU1 ---- ---- do_swap_page() do_swap_page() con la misma entrada     swap_read_folio()\
    \ &lt; - leer en la p\xE1gina A swap_read_folio() &lt;- leer en la p\xE1gina B\
    \   ... set_pte_at() swap_free() &lt;- la entrada es libre   pte_same() &lt;-\
    \ Verificar pase, PTE parece no haber cambiado, \xA1pero la p\xE1gina A est\xE1\
    \ estancada! swap_free() &lt;- \xA1Contenido de la p\xE1gina B perdido! set_pte_at()\
    \ &lt;- \xA1p\xE1gina A obsoleta instalada! Y adem\xE1s, para ZRAM, swap_free()\
    \ permite que el dispositivo de intercambio descarte el contenido de la entrada,\
    \ por lo que incluso si la p\xE1gina (B) no se modifica, si swap_read_folio()\
    \ en CPU0 ocurre m\xE1s tarde que swap_free() en CPU1, tambi\xE9n puede causar\
    \ que los datos p\xE9rdida. Para solucionar este problema, reutilice swapcache_prepare,\
    \ que fijar\xE1 la entrada de intercambio usando el indicador de cach\xE9 y permitir\xE1\
    \ que solo un hilo la intercambie, y tambi\xE9n evitar\xE1 que cualquier c\xF3\
    digo paralelo coloque la entrada en el cach\xE9. Suelte el pasador despu\xE9s\
    \ de desbloquear el PT. Los corredores simplemente dan vueltas y esperan, ya que\
    \ es un evento raro y muy corto. Se agrega una llamada Schedule_timeout_uninterruptible(1)\
    \ para evitar errores repetidos de p\xE1gina que desperdician demasiada CPU, provocando\
    \ bloqueos en vivo o agregando demasiado ruido a las estad\xEDsticas de rendimiento.\
    \ Un problema similar de livelock se describi\xF3 en el compromiso 029c4628b2eb\
    \ (\"mm: swap: deshacerse de livelock en swapin readahead\") Reproductor: este\
    \ problema de ejecuci\xF3n se puede activar f\xE1cilmente utilizando un reproductor\
    \ bien construido y un brd parcheado (con un retraso en la ruta de lectura) [\
    \ 1]: Con la \xFAltima l\xEDnea principal 6.8, la p\xE9rdida de datos causada\
    \ por la ejecuci\xF3n se puede observar f\xE1cilmente: $ gcc -g -lpthread test-thread-swap-race.c\
    \ &amp;&amp; ./a.out Contaminando 32 MB de regi\xF3n de memoria... Siga intercambiando.\
    \ .. Comenzando la ronda 0... Generando 65536 trabajadores... Se generaron 32746\
    \ trabajadores, espere a que termine... Ronda 0: Error en 0x5aa00, se esperaban\
    \ 32746, obtuve 32743, \xA13 p\xE9rdida de datos! Ronda 0: Error en 0x395200,\
    \ se esperaba 32746, obtuve 32743, \xA13 p\xE9rdida de datos! Ronda 0: Error en\
    \ 0x3fd000, esperado 32746, obtuve 32737, \xA19 p\xE9rdida de datos! Ronda 0 fallida,\
    \ \xA115 p\xE9rdida de datos! Este reproductor genera m\xFAltiples subprocesos\
    \ que comparten la misma regi\xF3n de memoria mediante un peque\xF1o dispositivo\
    \ de intercambio. Cada dos subprocesos actualiza las p\xE1ginas asignadas una\
    \ por una en direcci\xF3n opuesta tratando de crear una ejecuci\xF3n, con un subproceso\
    \ dedicado sigue intercambiando los datos usando madvise. El reproductor cre\xF3\
    \ una tasa de reproducci\xF3n de aproximadamente una vez cada 5 minutos, por lo\
    \ que la ejecuci\xF3n deber\xEDa ser totalmente posible en producci\xF3n. Despu\xE9\
    s de este parche, ejecut\xE9 el reproductor durante m\xE1s de unos cientos de\
    \ rondas y no se observ\xF3 p\xE9rdida de datos. ---truncado---"
id: CVE-2024-26759
lastModified: '2024-04-03T17:24:18.150'
metrics: {}
published: '2024-04-03T17:15:52.320'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/13ddaf26be324a7f951891ecd9ccd04466d27458
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/2dedda77d4493f3e92e414b272bfa60f1f51ed95
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/305152314df82b22cf9b181f3dc5fc411002079a
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/d183a4631acfc7af955c02a02e739cec15f5234d
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
