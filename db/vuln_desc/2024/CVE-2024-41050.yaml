cveTags: []
descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    cachefiles: cyclic allocation of msg_id to avoid reuse\n\nReusing the msg_id after\
    \ a maliciously completed reopen request may cause\na read request to remain unprocessed\
    \ and result in a hung, as shown below:\n\n       t1       |      t2       | \
    \     t3\n-------------------------------------------------\ncachefiles_ondemand_select_req\n\
    \ cachefiles_ondemand_object_is_close(A)\n cachefiles_ondemand_set_object_reopening(A)\n\
    \ queue_work(fscache_object_wq, &info->work)\n                ondemand_object_worker\n\
    \                 cachefiles_ondemand_init_object(A)\n                  cachefiles_ondemand_send_req(OPEN)\n\
    \                    // get msg_id 6\n                    wait_for_completion(&req_A->done)\n\
    cachefiles_ondemand_daemon_read\n // read msg_id 6 req_A\n cachefiles_ondemand_get_fd\n\
    \ copy_to_user\n                                // Malicious completion msg_id\
    \ 6\n                                copen 6,-1\n                            \
    \    cachefiles_ondemand_copen\n                                 complete(&req_A->done)\n\
    \                                 // will not set the object to close\n      \
    \                           // because ondemand_id && fd is valid.\n\n       \
    \         // ondemand_object_worker() is done\n                // but the object\
    \ is still reopening.\n\n                                // new open req_B\n \
    \                               cachefiles_ondemand_init_object(B)\n         \
    \                        cachefiles_ondemand_send_req(OPEN)\n                \
    \                 // reuse msg_id 6\nprocess_open_req\n copen 6,A.size\n // The\
    \ expected failed copen was executed successfully\n\nExpect copen to fail, and\
    \ when it does, it closes fd, which sets the\nobject to close, and then close\
    \ triggers reopen again. However, due to\nmsg_id reuse resulting in a successful\
    \ copen, the anonymous fd is not\nclosed until the daemon exits. Therefore read\
    \ requests waiting for reopen\nto complete may trigger hung task.\n\nTo avoid\
    \ this issue, allocate the msg_id cyclically to avoid reusing the\nmsg_id for\
    \ a very short duration of time."
- lang: es
  value: "En el kernel de Linux, se resolvi\xF3 la siguiente vulnerabilidad: archivos\
    \ de cach\xE9: asignaci\xF3n c\xEDclica de msg_id para evitar la reutilizaci\xF3\
    n La reutilizaci\xF3n de msg_id despu\xE9s de una solicitud de reapertura completada\
    \ maliciosamente puede causar que una solicitud de lectura permanezca sin procesar\
    \ y resulte en un bloqueo, como se muestra a continuaci\xF3n: t1 | t2 | t3 -------------------------------------------------\
    \ cachefiles_ondemand_select_req cachefiles_ondemand_object_is_close(A) cachefiles_ondemand_set_object_reopening(A)\
    \ queue_work(fscache_object_wq, &amp;info-&gt;work) ondemand_object_worker cachefiles_ondemand_init_object(A)\
    \ cachefiles_ondemand_send_req(OPEN) // obtener msg_id 6 _completion(&amp;req_A-&gt;done)\
    \ cachefiles_ondemand_daemon_read // leer msg_id 6 req_A cachefiles_ondemand_get_fd\
    \ copy_to_user // Finalizaci\xF3n maliciosa msg_id 6 copen 6,-1 cachefiles_ondemand_copen\
    \ complete(&amp;req_A-&gt;done) // no configurar\xE1 el objeto para que se cierre\
    \ // porque ondemand_id &amp;&amp; fd es v\xE1lido. // ondemand_object_worker()\
    \ est\xE1 listo // pero el objeto a\xFAn se est\xE1 reabriendo. // new open req_B\
    \ cachefiles_ondemand_init_object(B) cachefiles_ondemand_send_req(OPEN) // reutilizar\
    \ msg_id 6 process_open_req copen 6,A.size // El copen fallido esperado se ejecut\xF3\
    \ con \xE9xito Se espera que copen falle y, cuando lo hace, cierra fd, lo que\
    \ establece el objeto se cierra y luego el cierre activa nuevamente. Sin embargo,\
    \ debido a que la reutilizaci\xF3n de msg_id da como resultado un copen exitoso,\
    \ el fd an\xF3nimo no se cierra hasta que el demonio sale. Por lo tanto, las solicitudes\
    \ de lectura que esperan que se complete la reapertura pueden desencadenar una\
    \ tarea colgada. Para evitar este problema, asigne msg_id c\xEDclicamente para\
    \ evitar reutilizar msg_id durante un per\xEDodo de tiempo muy corto."
id: CVE-2024-41050
lastModified: '2024-07-29T16:21:52.517'
metrics: {}
published: '2024-07-29T15:15:13.260'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/19f4f399091478c95947f6bd7ad61622300c30d9
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/35710c6c4a1c64478ec1b5e0e81d386c0844dec6
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/9d3bf4e9aa23f0d9e99ebe7a94f232ddba54ee17
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  url: https://git.kernel.org/stable/c/de045a82e1a4e04be62718d3c2981a55150765a0
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Awaiting Analysis
