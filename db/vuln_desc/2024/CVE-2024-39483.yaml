configurations:
- nodes:
  - cpeMatch:
    - criteria: cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*
      matchCriteriaId: 18D12E25-2947-44E7-989D-24450E013A1F
      versionEndExcluding: '6.4'
      vulnerable: true
    - criteria: cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*
      matchCriteriaId: AC0C6E24-8240-425A-BD1A-F78E6D3A67FC
      versionEndExcluding: 6.6.34
      versionStartIncluding: '6.6'
      vulnerable: true
    - criteria: cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*
      matchCriteriaId: 54EDFD02-25E6-4BC8-9AD0-0A59881F400A
      versionEndExcluding: 6.9.5
      versionStartIncluding: '6.9'
      vulnerable: true
    - criteria: cpe:2.3:o:linux:linux_kernel:6.10.0:rc1:*:*:*:*:*:*
      matchCriteriaId: C40DD2D9-90E3-4E95-9F1A-E7C680F11F2A
      vulnerable: true
    - criteria: cpe:2.3:o:linux:linux_kernel:6.10.0:rc2:*:*:*:*:*:*
      matchCriteriaId: 54D5209E-E390-45C5-A5D1-C9EDB40819F7
      vulnerable: true
    negate: false
    operator: OR
cveTags: []
descriptions:
- lang: en
  value: 'In the Linux kernel, the following vulnerability has been resolved:


    KVM: SVM: WARN on vNMI + NMI window iff NMIs are outright masked


    When requesting an NMI window, WARN on vNMI support being enabled if and

    only if NMIs are actually masked, i.e. if the vCPU is already handling an

    NMI.  KVM''s ABI for NMIs that arrive simultanesouly (from KVM''s point of

    view) is to inject one NMI and pend the other.  When using vNMI, KVM pends

    the second NMI simply by setting V_NMI_PENDING, and lets the CPU do the

    rest (hardware automatically sets V_NMI_BLOCKING when an NMI is injected).


    However, if KVM can''t immediately inject an NMI, e.g. because the vCPU is

    in an STI shadow or is running with GIF=0, then KVM will request an NMI

    window and trigger the WARN (but still function correctly).


    Whether or not the GIF=0 case makes sense is debatable, as the intent of

    KVM''s behavior is to provide functionality that is as close to real

    hardware as possible.  E.g. if two NMIs are sent in quick succession, the

    probability of both NMIs arriving in an STI shadow is infinitesimally low

    on real hardware, but significantly larger in a virtual environment, e.g.

    if the vCPU is preempted in the STI shadow.  For GIF=0, the argument isn''t

    as clear cut, because the window where two NMIs can collide is much larger

    in bare metal (though still small).


    That said, KVM should not have divergent behavior for the GIF=0 case based

    on whether or not vNMI support is enabled.  And KVM has allowed

    simultaneous NMIs with GIF=0 for over a decade, since commit 7460fb4a3400

    ("KVM: Fix simultaneous NMIs").  I.e. KVM''s GIF=0 handling shouldn''t be

    modified without a *really* good reason to do so, and if KVM''s behavior

    were to be modified, it should be done irrespective of vNMI support.'
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: KVM:\
    \ SVM: WARN en la ventana vNMI + NMI si los NMI est\xE1n completamente enmascarados\
    \ Al solicitar una ventana NMI, WARN en la ventana de vNMI est\xE1 habilitado\
    \ si y solo si los NMI est\xE1n realmente enmascarados, es decir, si la vCPU ya\
    \ est\xE1 manejando una NMI. La ABI de KVM para NMI que llegan simult\xE1neamente\
    \ (desde el punto de vista de KVM) es inyectar un NMI y esperar el otro. Cuando\
    \ se usa vNMI, KVM suspende el segundo NMI simplemente configurando V_NMI_PENDING\
    \ y deja que la CPU haga el resto (el hardware configura autom\xE1ticamente V_NMI_BLOCKING\
    \ cuando se inyecta un NMI). Sin embargo, si KVM no puede inyectar inmediatamente\
    \ una NMI, por ejemplo, porque la vCPU est\xE1 en una sombra STI o se est\xE1\
    \ ejecutando con GIF=0, entonces KVM solicitar\xE1 una ventana NMI y activar\xE1\
    \ el WARN (pero seguir\xE1 funcionando correctamente). Es discutible si el caso\
    \ GIF=0 tiene sentido o no, ya que la intenci\xF3n del comportamiento de KVM es\
    \ proporcionar una funcionalidad lo m\xE1s cercana posible al hardware real. Por\
    \ ejemplo, si se env\xEDan dos NMI en r\xE1pida sucesi\xF3n, la probabilidad de\
    \ que ambos NMI lleguen a una sombra de STI es infinitamente baja en hardware\
    \ real, pero significativamente mayor en un entorno virtual, por ejemplo, si la\
    \ vCPU tiene prioridad en la sombra de STI. Para GIF=0, el argumento no es tan\
    \ claro, porque la ventana donde dos NMI pueden colisionar es mucho mayor en el\
    \ metal desnudo (aunque a\xFAn es peque\xF1a). Dicho esto, KVM no deber\xEDa tener\
    \ un comportamiento divergente para el caso GIF=0 en funci\xF3n de si la compatibilidad\
    \ con vNMI est\xE1 habilitada o no. Y KVM ha permitido NMI simult\xE1neas con\
    \ GIF=0 durante m\xE1s de una d\xE9cada, desde el commit 7460fb4a3400 (\"KVM:\
    \ Reparar NMI simult\xE1neas\"). Es decir, el manejo de GIF=0 de KVM no debe modificarse\
    \ sin una *realmente* buena raz\xF3n para hacerlo, y si se modifica el comportamiento\
    \ de KVM, debe hacerse independientemente del soporte de vNMI."
id: CVE-2024-39483
lastModified: '2024-07-08T18:00:08.430'
metrics:
  cvssMetricV31:
  - cvssData:
      attackComplexity: LOW
      attackVector: LOCAL
      availabilityImpact: HIGH
      baseScore: 5.5
      baseSeverity: MEDIUM
      confidentialityImpact: NONE
      integrityImpact: NONE
      privilegesRequired: LOW
      scope: UNCHANGED
      userInteraction: NONE
      vectorString: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
      version: '3.1'
    exploitabilityScore: 1.8
    impactScore: 3.6
    source: nvd@nist.gov
    type: Primary
published: '2024-07-05T07:15:10.767'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  tags:
  - Mailing List
  - Patch
  url: https://git.kernel.org/stable/c/1d87cf2eba46deaff6142366127f2323de9f84d1
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  tags:
  - Mailing List
  - Patch
  url: https://git.kernel.org/stable/c/b4bd556467477420ee3a91fbcba73c579669edc6
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  tags:
  - Mailing List
  - Patch
  url: https://git.kernel.org/stable/c/f79edaf7370986d73d204b36c50cc563a4c0f356
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Analyzed
weaknesses:
- description:
  - lang: en
    value: NVD-CWE-noinfo
  source: nvd@nist.gov
  type: Primary
