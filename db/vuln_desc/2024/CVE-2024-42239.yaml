configurations:
- nodes:
  - cpeMatch:
    - criteria: cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*
      matchCriteriaId: DA87C02E-A4BF-4FD7-AE47-A2AB23061A91
      versionEndExcluding: 6.6.41
      versionStartIncluding: '5.15'
      vulnerable: true
    - criteria: cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*
      matchCriteriaId: AB2E8DEC-CFD5-4C2B-981D-E7E45A36C352
      versionEndExcluding: 6.9.10
      versionStartIncluding: '6.7'
      vulnerable: true
    negate: false
    operator: OR
cveTags: []
descriptions:
- lang: en
  value: "In the Linux kernel, the following vulnerability has been resolved:\n\n\
    bpf: Fail bpf_timer_cancel when callback is being cancelled\n\nGiven a schedule:\n\
    \ntimer1 cb\t\t\ttimer2 cb\n\nbpf_timer_cancel(timer2);\tbpf_timer_cancel(timer1);\n\
    \nBoth bpf_timer_cancel calls would wait for the other callback to finish\nexecuting,\
    \ introducing a lockup.\n\nAdd an atomic_t count named 'cancelling' in bpf_hrtimer.\
    \ This keeps\ntrack of all in-flight cancellation requests for a given BPF timer.\n\
    Whenever cancelling a BPF timer, we must check if we have outstanding\ncancellation\
    \ requests, and if so, we must fail the operation with an\nerror (-EDEADLK) since\
    \ cancellation is synchronous and waits for the\ncallback to finish executing.\
    \ This implies that we can enter a deadlock\nsituation involving two or more timer\
    \ callbacks executing in parallel\nand attempting to cancel one another.\n\nNote\
    \ that we avoid incrementing the cancelling counter for the target\ntimer (the\
    \ one being cancelled) if bpf_timer_cancel is not invoked from\na callback, to\
    \ avoid spurious errors. The whole point of detecting\ncur->cancelling and returning\
    \ -EDEADLK is to not enter a busy wait loop\n(which may or may not lead to a lockup).\
    \ This does not apply in case the\ncaller is in a non-callback context, the other\
    \ side can continue to\ncancel as it sees fit without running into errors.\n\n\
    Background on prior attempts:\n\nEarlier versions of this patch used a bool 'cancelling'\
    \ bit and used the\nfollowing pattern under timer->lock to publish cancellation\
    \ status.\n\nlock(t->lock);\nt->cancelling = true;\nmb();\nif (cur->cancelling)\n\
    \treturn -EDEADLK;\nunlock(t->lock);\nhrtimer_cancel(t->timer);\nt->cancelling\
    \ = false;\n\nThe store outside the critical section could overwrite a parallel\n\
    requests t->cancelling assignment to true, to ensure the parallely\nexecuting\
    \ callback observes its cancellation status.\n\nIt would be necessary to clear\
    \ this cancelling bit once hrtimer_cancel\nis done, but lack of serialization\
    \ introduced races. Another option was\nexplored where bpf_timer_start would clear\
    \ the bit when (re)starting the\ntimer under timer->lock. This would ensure serialized\
    \ access to the\ncancelling bit, but may allow it to be cleared before in-flight\n\
    hrtimer_cancel has finished executing, such that lockups can occur\nagain.\n\n\
    Thus, we choose an atomic counter to keep track of all outstanding\ncancellation\
    \ requests and use it to prevent lockups in case callbacks\nattempt to cancel\
    \ each other while executing in parallel."
- lang: es
  value: "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bpf:\
    \ falla bpf_timer_cancel cuando se cancela la devoluci\xF3n de llamada. Dada una\
    \ programaci\xF3n: timer1 cb timer2 cb bpf_timer_cancel(timer2); bpf_timer_cancel(timer1);\
    \ Ambas llamadas a bpf_timer_cancel esperar\xEDan a que la otra devoluci\xF3n\
    \ de llamada termine de ejecutarse, introduciendo un bloqueo. Agregue un recuento\
    \ atomic_t llamado 'cancelaci\xF3n' en bpf_hrtimer. Esto realiza un seguimiento\
    \ de todas las solicitudes de cancelaci\xF3n en vuelo para un temporizador BPF\
    \ determinado. Siempre que cancelemos un temporizador BPF, debemos verificar si\
    \ tenemos solicitudes de cancelaci\xF3n pendientes y, de ser as\xED, debemos fallar\
    \ la operaci\xF3n con un error (-EDEADLK) ya que la cancelaci\xF3n es sincr\xF3\
    nica y espera a que termine de ejecutarse la devoluci\xF3n de llamada. Esto implica\
    \ que podemos entrar en una situaci\xF3n de punto muerto que involucre dos o m\xE1\
    s devoluciones de llamada de temporizador ejecut\xE1ndose en paralelo e intentando\
    \ cancelarse entre s\xED. Tenga en cuenta que evitamos incrementar el contador\
    \ de cancelaci\xF3n para el temporizador de destino (el que se cancela) si no\
    \ se invoca bpf_timer_cancel desde una devoluci\xF3n de llamada, para evitar errores\
    \ falsos. El objetivo de detectar cur-&gt;cancelar y devolver -EDEADLK es no ingresar\
    \ a un ciclo de espera ocupado (que puede o no conducir a un bloqueo). Esto no\
    \ se aplica en caso de que la persona que llama se encuentre en un contexto sin\
    \ devoluci\xF3n de llamada; la otra parte puede continuar cancelando como mejor\
    \ le parezca sin cometer errores. Antecedentes de intentos anteriores: Las versiones\
    \ anteriores de este parche usaban un bit bool de 'cancelaci\xF3n' y usaban el\
    \ siguiente patr\xF3n en temporizador-&gt;bloqueo para publicar el estado de cancelaci\xF3\
    n.  lock(t-&gt;lock); t-&gt;cancelling = true; mb(); if (cur-&gt;cancelling) return\
    \ -EDEADLK; unlock(t-&gt;lock); hrtimer_cancel(t-&gt;timer); t-&gt;cancelling\
    \ = false; El almac\xE9n fuera de la secci\xF3n cr\xEDtica podr\xEDa sobrescribir\
    \ una asignaci\xF3n de cancelaci\xF3n t-&gt;de solicitudes paralelas a verdadero,\
    \ para garantizar que la devoluci\xF3n de llamada que se ejecuta en paralelo observe\
    \ su estado de cancelaci\xF3n. Ser\xEDa necesario borrar este bit de cancelaci\xF3\
    n una vez que se complete hrtimer_cancel, pero la falta de serializaci\xF3n introdujo\
    \ ejecuciones. Se explor\xF3 otra opci\xF3n donde bpf_timer_start borrar\xEDa\
    \ el bit al (re)iniciar el temporizador bajo temporizador-&gt;bloqueo. Esto garantizar\xED\
    a el acceso serializado al bit de cancelaci\xF3n, pero puede permitir que se borre\
    \ antes de que hrtimer_cancel en vuelo haya terminado de ejecutarse, de modo que\
    \ los bloqueos puedan ocurrir nuevamente. Por lo tanto, elegimos un contador at\xF3\
    mico para realizar un seguimiento de todas las solicitudes de cancelaci\xF3n pendientes\
    \ y lo utilizamos para evitar bloqueos en caso de que las devoluciones de llamada\
    \ intenten cancelarse entre s\xED mientras se ejecutan en paralelo."
id: CVE-2024-42239
lastModified: '2024-08-08T14:54:08.330'
metrics:
  cvssMetricV31:
  - cvssData:
      attackComplexity: LOW
      attackVector: LOCAL
      availabilityImpact: HIGH
      baseScore: 5.5
      baseSeverity: MEDIUM
      confidentialityImpact: NONE
      integrityImpact: NONE
      privilegesRequired: LOW
      scope: UNCHANGED
      userInteraction: NONE
      vectorString: CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H
      version: '3.1'
    exploitabilityScore: 1.8
    impactScore: 3.6
    source: nvd@nist.gov
    type: Primary
published: '2024-08-07T16:15:46.733'
references:
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  tags:
  - Patch
  url: https://git.kernel.org/stable/c/3e4e8178a8666c56813bd167b848fca0f4c9af0a
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  tags:
  - Patch
  url: https://git.kernel.org/stable/c/9369830518688ecd5b08ffc08ab3302ce2b5d0f7
- source: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
  tags:
  - Patch
  url: https://git.kernel.org/stable/c/d4523831f07a267a943f0dde844bf8ead7495f13
sourceIdentifier: 416baaa9-dc9f-4396-8d5f-8c081fb06d67
vulnStatus: Analyzed
weaknesses:
- description:
  - lang: en
    value: CWE-667
  source: nvd@nist.gov
  type: Primary
